{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1737341374748975105",
        "title": "TextCNN文本分类模型在文章评论审核中的实现与部署",
        "description": "网络上的\"喷子\"现象导致新闻文章评论区充斥着大量谩骂言辞。为了提升平台品质和用户体验，急需解决如何自动拦截这些谩骂评论的问题。本文旨在通过构建卷积神经网络模型，实现对谩骂评论的自动识别，以机器方式对抗这些网络喷子。",
        "content": "# 三、文章评论审核TextCnn文本分类模型实现和部署\n\n网络上的\"喷子\"现象导致新闻文章评论区充斥着大量谩骂言辞。为了提升平台品质和用户体验，急需解决如何自动拦截这些谩骂评论的问题。本文旨在通过构建卷积神经网络模型，实现对谩骂评论的自动识别，以机器方式对抗这些网络喷子。\n\n在新闻文章评论中，经常可见包括对新闻人物的辱骂、对编辑的恶语以及评论回复中对楼主的攻击等谩骂言辞，这不仅损害了平台的声誉和品质，更直接影响了用户的使用体验。因此，减少谩骂评论的出现成为迫切需要解决的问题。鉴于评论数量庞大，仅依赖人工审核显然是不切实际的。我们的目标是建立一种自动识别算法，通过模型拦截这些脏话脏语，从而有效净化评论区。\n\n## 1. 算法结构和思路\n\n![WXKcJ.png](https://i.imgs.ovh/2023/12/20/WXKcJ.png)\n\n1.  **预处理阶段**： \n\n- - **文本清洗**：去除无关字符、标点符号，统一大小写等，以规范输入文本。\n  - **分词处理**：将文本划分为词汇，有助于更精准地进行后续检测。\n\n2.  **辱骂违规词检测**： \n\n- - **建立违规词库**：维护一个包含辱骂和不当言辞的词汇库，定期更新以适应新的网络用语。\n  - **多层次匹配**：采用多层次的匹配策略，包括精确匹配、模糊匹配和同义词匹配，提高检测的准确性。\n  - **动态过滤**：考虑引入动态过滤机制，即根据用户行为和社交网络动态，调整违规词库，使其更符合实际使用情境。\n\n3.  **政治敏感词检测**： \n\n- - **建立敏感词库**：创建一个包含政治敏感词汇的库，以便检测涉及政治敏感话题的评论。\n  - **关联性分析**：考虑评论中词汇的关联性，以防止误判。某些词汇可能在特定上下文中并非政治敏感，因此需要综合考虑。\n\n4.  **TextCNN模型**： \n\n- - **模型架构**：确保TextCNN模型具有合适的深度和广度，以捕捉评论中的语义和上下文信息。\n  - **多通道卷积**：考虑使用多个卷积核和多通道的卷积层，以捕获不同尺度的特征。\n\n5.  **输出和审核结果**： \n\n- - **综合判断**：融合辱骂违规词检测、政治敏感词检测和TextCNN模型的输出，形成最终的审核决策。\n  - **可解释性**：为了提高模型的可解释性，记录各个阶段的判断结果，以便后续调整和分析。\n\n**总结逻辑设计的好处**：\n\n-  **多层次策略**：通过多层次的违规词检测和模型判断，提高了对违规评论的综合判断能力。 \n-  **实时适应性**：动态过滤机制和动态更新词库能够使模型更好地适应不断变化的网络用语和社交动态。 \n-  **综合性能**：综合利用违规词检测和深度学习模型，既考虑了明显的违规用语，也能够处理语义和上下文信息。 \n-  **可解释性**：记录各个阶段的判断结果，有助于理解模型的决策过程，方便进一步优化和维护。 \n\n通过这样细致和综合的设计，可以提高评论审核模型的准确性和鲁棒性，更好地满足实际需求。\n\n## 2. 数据来源\n\n- 参考文章：https://cloud.tencent.com/developer/article/1068648\n- 数据来源：https://github.com/wjx-git/IllegalTextDetection\n\n## 3. 模型选择\n\n### 3.1. 结构\n\n以下是TextCNN模型的结构图，结构简单，即使在CPU也能训练：\n\n```yaml\nInput: 文本序列 (batch, sentence_length)\n\n       |\n       V\n\nEmbedding层:  (batch, sentence_length, embed_dim)\n\n       |  \\\n       V   V\n\nConv2D + ReLU + MaxPool: (batch, kernel_num)   (conv11)\n       |\n       V\n\nConv2D + ReLU + MaxPool: (batch, kernel_num)   (conv12)\n       |\n       V\n\nConv2D + ReLU + MaxPool: (batch, kernel_num)   (conv13)\n       |\n       V\n\n       |      |      |\n       V      V      V\n\nConcatenate: (batch, 3 * kernel_num)\n\n       |\n       V\n\nDropout层: (batch, 3 * kernel_num)\n\n       |\n       V\n\n全连接层: 输出 (batch, class_num)\n```\n\n### 3.2. 分层解析\n\n1.  **Embedding层**： \n\n- - **作用**：将输入的文本序列中的每个词汇映射为对应的词向量，提供词汇的语义信息。\n\n2.  **Conv2D + ReLU + MaxPool**（conv11、conv12、conv13，三个相同结构的层）： \n\n- - **作用**：这三个层组成了多个不同尺寸的卷积核，用于捕捉输入文本中不同尺度的语义特征。\n  - **Conv2D**：卷积操作用于检测输入文本中的局部模式。\n  - **ReLU**：激活函数引入非线性，增强模型表达能力。\n  - **MaxPool**：最大池化操作用于降维，保留最显著的特征。\n\n3.  **Concatenate**： \n\n- - **作用**：将三个卷积核得到的不同尺度的特征连接在一起，使模型能够同时考虑多个尺度的语义信息。\n\n4.  **Dropout层**： \n\n- - **作用**：在训练过程中随机丢弃部分神经元，减少过拟合的风险。\n\n5.  **全连接层**： \n\n- - **作用**：将连接后的特征映射到最终的输出类别空间，用于文本分类任务。\n\n这个textCNN模型通过嵌入层、卷积层、全连接层等组件，能够有效地捕捉输入文本的语义信息，并用于文本分类。\n\n### 3.3. 关于嵌入层\n\n当我们使用嵌入层时，我们将每个单词的索引映射为一个词向量。让我们假设我们有一个词汇表，其中包含5个单词：['I', 'love', 'natural', 'language', 'processing']，并且我们选择一个嵌入维度 `embed_dim` 为 4。\n\n\n\n如果我们的输入文本是 \"I love language\"，我们可以将它表示为索引序列 [0, 1, 3]，其中 \"I\" 的索引是 0，\"love\" 的索引是 1，\"language\" 的索引是 3。\n\n\n\n通过嵌入层，我们可以将这些索引映射为词向量。假设我们的嵌入层参数是随机初始化的，那么可能的映射如下：\n\n\n\n```plain\nEmbedding Matrix:\n[[ 0.1,  0.2,  0.3,  0.4],  # 对应 \"I\"\n [ 0.5,  0.6,  0.7,  0.8],  # 对应 \"love\"\n [ 0.9,  1.0,  1.1,  1.2],  # 对应 \"natural\"\n [ 1.3,  1.4,  1.5,  1.6],  # 对应 \"language\"\n [ 1.7,  1.8,  1.9,  2.0]]  # 对应 \"processing\"\n\n输入序列 [0, 1, 3] 对应的词向量：\n[[ 0.1,  0.2,  0.3,  0.4],  # 对应 \"I\"\n [ 0.5,  0.6,  0.7,  0.8],  # 对应 \"love\"\n [ 1.3,  1.4,  1.5,  1.6]]  # 对应 \"language\"\n```\n\n\n\n这就是嵌入层的作用：将文本中的单词索引映射为对应的词向量。这些词向量将成为模型的输入，帮助模型理解文本中的语义信息。在训练的过程中，这些嵌入矩阵的权重会被学习，以更好地适应具体的任务。\n\n在文本处理中，原始的单词索引是一维的，通过嵌入操作，我们将这一维的离散索引映射为连续的词向量，从而引入了更多的语义信息。嵌入操作将原始的离散表示转换成密集的连续表示，这样模型可以更好地理解词汇之间的语义关系。\n\n嵌入的维度（`embed_dim`）通常是一个超参数，可以根据任务和数据集的性质进行调整。较大的嵌入维度能够提供更丰富的语义信息，但也需要更多的计算资源和数据来进行训练。\n\n\n\n## 4. 数据处理\n\n本文的数据处理过程涵盖以下主要步骤：\n\n1. 通过对原始数据集 `train.txt` 进行处理，生成词表 `word_list.txt`。为了提升词表的容量，我们并未设定单词阈值，而是完全将所有单词纳入词表中。\n\n![WX7d3.png](https://i.imgs.ovh/2023/12/20/WX7d3.png)\n\n2. 利用生成的词表 `word_list.txt`，将 `train.txt`、`dev.txt` 和 `test.txt` 转换为相应的单词索引向量。\n\n![WXQ29.png](https://i.imgs.ovh/2023/12/20/WXQ29.png)\n## 5. 模型训练和验证\n\n### 5.1. 代码文件\n\n![WXt6o.png](https://i.imgs.ovh/2023/12/20/WXt6o.png)\n\n### 5.2. 训练环境\n\n采用Python3.9，conda环境，\n\n可手动安装以下依赖（不写版本号默认最新版）其余依赖应该会自动装好，如果没有，按需安装即可：\n\n1. pytorch（从官方下载自己设备适配的版本即可）\n2. jieba\n3. nltk\n4. pandas\n5. re（Python自带）\n6. tqdm\n7. numpy\n8. flask\n9. flask_cors\n10. gunicorn（处理高并发的服务器，云部署时用）\n\n所有依赖包信息如下：\n\n> Package                  Version\n>\n> ------------------------ -----------\n>\n> anyio                    3.6.2\n>\n> argon2-cffi              21.3.0\n>\n> argon2-cffi-bindings     21.2.0\n>\n> asttokens                2.2.1\n>\n> attrs                    22.2.0\n>\n> backcall                 0.2.0\n>\n> beautifulsoup4           4.11.1\n>\n> bleach                   6.0.0\n>\n> blinker                  1.7.0\n>\n> bs4                      0.0.1\n>\n> certifi                  2022.12.7\n>\n> cffi                     1.15.1\n>\n> chardet                  4.0.0\n>\n> charset-normalizer       3.0.1\n>\n> click                    8.1.7\n>\n> cloudpickle              2.2.1\n>\n> colorama                 0.4.6\n>\n> comm                     0.1.2\n>\n> contourpy                1.0.5\n>\n> cycler                   0.11.0\n>\n> d2l                      0.17.6\n>\n> debugpy                  1.6.6\n>\n> decorator                5.1.1\n>\n> defusedxml               0.7.1\n>\n> et-xmlfile               1.1.0\n>\n> executing                1.2.0\n>\n> filelock                 3.13.1\n>\n> Flask                    3.0.0\n>\n> Flask-Cors               4.0.0\n>\n> fonttools                4.37.4\n>\n> fsspec                   2023.12.2\n>\n> idna                     2.10\n>\n> imageio                  2.26.0\n>\n> importlib-metadata       6.0.0\n>\n> ipykernel                6.20.2\n>\n> ipython                  8.8.0\n>\n> ipython-genutils         0.2.0\n>\n> ipywidgets               8.0.4\n>\n> itsdangerous             2.1.2\n>\n> jdcal                    1.4.1\n>\n> jedi                     0.18.2\n>\n> jieba                    0.42.1\n>\n> Jinja2                   3.1.2\n>\n> joblib                   1.3.2\n>\n> jsonschema               4.17.3\n>\n> jupyter                  1.0.0\n>\n> jupyter_client           8.0.1\n>\n> jupyter-console          6.4.4\n>\n> jupyter_core             5.1.5\n>\n> jupyter-events           0.6.3\n>\n> jupyter_server           2.1.0\n>\n> jupyter_server_terminals 0.4.4\n>\n> jupyterlab-pygments      0.2.2\n>\n> jupyterlab-widgets       3.0.5\n>\n> kiwisolver               1.4.4\n>\n> lazy_loader              0.1\n>\n> MarkupSafe               2.1.2\n>\n> matplotlib               3.5.1\n>\n> matplotlib-inline        0.1.6\n>\n> mistune                  2.0.4\n>\n> mpmath                   1.3.0\n>\n> nbclassic                0.5.1\n>\n> nbclient                 0.7.2\n>\n> nbconvert                7.2.9\n>\n> nbformat                 5.7.3\n>\n> nest-asyncio             1.5.6\n>\n> networkx                 3.2.1\n>\n> nltk                     3.8.1\n>\n> notebook                 6.5.2\n>\n> notebook_shim            0.2.2\n>\n> numpy                    1.26.2\n>\n> openpyxl                 3.2.0b1\n>\n> packaging                21.3\n>\n> pandas                   2.1.4\n>\n> pandocfilters            1.5.0\n>\n> parso                    0.8.3\n>\n> pickleshare              0.7.5\n>\n> Pillow                   9.2.0\n>\n> pip                      23.3.1\n>\n> platformdirs             2.6.2\n>\n> prometheus-client        0.16.0\n>\n> prompt-toolkit           3.0.36\n>\n> psutil                   5.9.4\n>\n> psycopg2                 2.9.6\n>\n> pure-eval                0.2.2\n>\n> pycparser                2.21\n>\n> pygad                    2.19.2\n>\n> Pygments                 2.14.0\n>\n> pyparsing                3.0.9\n>\n> pyrsistent               0.19.3\n>\n> python-dateutil          2.8.2\n>\n> python-json-logger       2.0.4\n>\n> pytz                     2022.4\n>\n> PyWavelets               1.4.1\n>\n> pywin32                  305\n>\n> pywinpty                 2.0.10\n>\n> pyzmq                    25.0.0\n>\n> qtconsole                5.4.0\n>\n> QtPy                     2.3.0\n>\n> regex                    2023.10.3\n>\n> requests                 2.25.1\n>\n> rfc3339-validator        0.1.4\n>\n> rfc3986-validator        0.1.1\n>\n> Send2Trash               1.8.0\n>\n> sentencepiece            0.1.99\n>\n> setuptools               68.2.2\n>\n> six                      1.16.0\n>\n> sklearn                  0.0.post1\n>\n> sniffio                  1.3.0\n>\n> soupsieve                2.3.2.post1\n>\n> stack-data               0.6.2\n>\n> sympy                    1.12\n>\n> terminado                0.17.1\n>\n> tifffile                 2023.2.28\n>\n> tinycss2                 1.2.1\n>\n> torch                    2.1.2\n>\n> torchaudio               2.1.2\n>\n> torchdata                0.7.1\n>\n> torchtext                0.6.0\n>\n> torchvision              0.16.2\n>\n> tornado                  6.2\n>\n> tqdm                     4.66.1\n>\n> traitlets                5.8.1\n>\n> typing_extensions        4.4.0\n>\n> tzdata                   2023.3\n>\n> urllib3                  1.26.14\n>\n> wcwidth                  0.2.6\n>\n> webencodings             0.5.1\n>\n> websocket-client         1.5.0\n>\n> Werkzeug                 3.0.1\n>\n> wheel                    0.41.2\n>\n> widgetsnbextension       4.0.5\n>\n> xlrd                     2.0.1\n>\n> zipp                     3.11.0\n\n### 5.3. 训练信息\n\n这段模型训练文件的相关信息总结如下：\n\n### 模型结构\n\n- **textCNN模型**： \n\n- - 输入：文本序列\n  - 嵌入层：词表大小为 `vocab_size`，嵌入维度为 `embed_dim`\n  - 三个卷积核（kernel_num=16）：分别大小为 3、4、5\n  - Dropout层：丢弃率为 0.5\n  - 全连接层：输出类别数量为 `class_num`（这里为2）\n\n### 数据处理\n\n- 通过 `word2vec` 模块加载词表映射，得到 `word2ind` 和 `ind2word`。\n- 数据集参数 `dataLoader_param`： \n\n- - `batch_size`: 128\n  - `shuffle`: True\n\n### 训练过程\n\n- 优化器：Adam，学习率为 0.01\n- 损失函数：负对数似然损失（NLLLoss）\n- 模型参数初始化： \n\n- - 如果已存在保存的权重文件 `textCNN.pkl`，则加载权重\n  - 否则，使用 `init_weight` 方法初始化权重\n\n- 日志记录：每个epoch记录每个batch的训练损失，保存在日志文件 `log_YYMMDDHH.txt` 中。\n- 训练时遍历数据集，进行前向传播、计算损失、反向传播更新参数。\n- 每50个batch输出一次当前epoch的训练损失。\n- 每个epoch结束后输出该epoch的平均训练损失。\n- 训练总共进行了100个epoch。\n\n### 模型保存\n\n- 训练完成后，保存模型权重到文件 `textCNN.pkl`。\n\n### 5.4. 训练结果\n\n![WXJ95.png](https://i.imgs.ovh/2023/12/20/WXJ95.png)\n\n最后，经过100轮训练，可将验证损失控制在0.01，效果良好。\n\n## 6. 模型测试\n\n经过类似的步骤，执行test.py文件即可得到测试结果，并将结果保存至日志文件log_test中\n\n![WXiuX.png](https://i.imgs.ovh/2023/12/20/WXiuX.png)\n\n可以看到，测试准确率也维持在97%以上，模型可用。\n\n## 7. 本地部署\n\n主要利用Flask进行本地网络api部署，操作简单易行，同时提供了html页面进行简单测试，也可使用接口测试工具如apifox、postman进行测试。\n\n### 7.1. 代码文件\n\n![WXjdU.png](https://i.imgs.ovh/2023/12/20/WXjdU.png)\n\n### 7.2. api解析\n\n![WXYsC.png](https://i.imgs.ovh/2023/12/20/WXYsC.png)\n\n### 7.3. 网页html测试\n\n![WXdUt.png](https://i.imgs.ovh/2023/12/20/WXdUt.png)\n\n### 7.4. 接口测试工具测试\n\n这里以apifox为例：\n\n![WXDPm.png](https://i.imgs.ovh/2023/12/20/WXDPm.png)\n\n## 8. 云部署\n\n### 8.1. 部署环境\n\n- 阿里云轻量应用服务器，系统为centos7\n- conda环境：如未安装，可参考此博客：https://blog.csdn.net/wyf2017/article/details/118676765\n- 使用前根据本文5.2安装依赖即可\n- 记得将本地文件上传至服务器\n\n### 8.2. 配置并使用Gunicorn 服务\n\n#### 8.2.1. 什么是Gunicorn 服务\n\n在生产环境中，Flask自带的开发服务器通常不适用于处理高负载和并发请求。Flask的开发服务器是单线程的，并不是为了处理大量并发请求而设计的。它更适合在开发环境中使用，用于调试和测试。\n\n以下是使用 Flask开发服务器的一些主要限制：\n\n1.  **单线程处理请求：** Flask的开发服务器是单线程的，意味着它一次只能处理一个请求。在高并发情况下，这可能导致性能瓶颈。 \n2.  **不适合生产环境：** Flask的开发服务器没有被设计为在生产环境中处理大规模负载的工具。它缺乏许多生产服务器所具有的优化和安全功能。 \n3.  **有安全风险：** Flask的开发服务器没有像生产级服务器那样经过严格的安全审查和配置。在生产环境中使用它可能会增加安全风险。 \n\n为了解决这些问题，通常建议在生产环境中使用专业的Web服务器，如Gunicorn、uWSGI等。这些服务器可以处理更多的并发请求，提供更好的性能和安全性，并具有适用于生产环境的配置选项。\n\nGunicorn就是在生产环境中使用专业的Web服务器。\n\n#### 8.2.2. 如何使用\n\n在使用 Gunicorn 启动 Flask 应用时，可以使用 Gunicorn 的 `--workers` 选项指定工作进程的数量，以实现并发处理请求。每个工作进程都是一个独立的进程，可以独立运行应用代码。\n\n以下是一些示例命令，演示如何在 Gunicorn 中启动 Flask 应用并设置多个工作进程：\n\n```bash\ngunicorn -w 4 -b 0.0.0.0:9102 predict_online:app\n```\n\n在这个例子中：\n\n- `-w 4` 指定了使用 4 个工作进程。\n- `-b 0.0.0.0:9102` 指定了绑定的地址和端口。\n- `predict_online:app` 指定了要运行的 Flask 应用。\n\n请注意，`predict_online` 应该是你文件中定义 Flask 应用的地方。\n\n此外，你可以考虑使用 Gunicorn 的其他配置选项，例如 `--preload`，这将在每个工作进程启动时加载应用代码，而不是在每个请求中加载。这样可以减少工作进程的启动时间，提高性能。\n\n```bash\ngunicorn -w 4 -b 0.0.0.0:9102 --preload predict_online:app\n```\n\n确保在生产环境中使用专业的 Web 服务器（如 Gunicorn）来运行 Flask 应用，以确保应用能够正确处理并发请求并保持稳定性。\n\n当使用 Gunicorn 的 `--preload` 选项时，应用代码会在每个工作进程启动时加载，而不是在每个请求中动态加载。这个过程称为应用的“预加载”。\n\n**动态加载（非预加载）**：\n\n在动态加载模式下，每当接收到一个请求时，Gunicorn 会动态地加载应用代码并初始化应用。这意味着在每个请求处理之前，都会执行一次应用的初始化过程。这种方式的好处是在运行时可以动态更新应用代码，但也可能导致每个请求都需要花费额外的时间来加载和初始化应用。\n\n**预加载**：\n\n在预加载模式下，应用代码会在工作进程启动时加载和初始化。这意味着在工作进程启动时，应用的所有代码都被加载到内存中，并且在处理请求时无需再次加载。这样一来，每个请求的处理过程更加高效，因为不需要在请求级别进行初始化操作。然而，这也意味着在更新应用代码时，你需要重新启动工作进程，以便使新的代码生效。\n\n假设你有一个 Flask 应用，其中包含一些全局变量或初始化操作。在动态加载模式下，这些初始化操作会在每个请求中执行。在预加载模式下，这些初始化操作会在工作进程启动时执行，而不会在每个请求中重复执行。\n\n在动态加载模式下，`some_global_variable` 的初始化操作将在每个请求中执行。在预加载模式下，初始化操作只会在工作进程启动时执行一次，而后续的请求将直接使用已初始化的变量，而不需要重新执行初始化。\n\n\n\n#### 8.2.3. worker和负载均衡\n\n在 Gunicorn 中，worker 是处理请求的工作单元，而 master 则是管理这些 worker 的主进程。在 Gunicorn 的工作模型中，master 进程负责监听端口、接收请求，并将请求分配给不同的 worker 进程进行处理。\n\nGunicorn 支持多种 worker 类型，包括 sync（同步）、eventlet、gevent、tornado 等。这些 worker 的主要区别在于它们处理请求的方式。下面是关于 Gunicorn worker 的一些关键概念：\n\n1.  **Master 进程**： \n\n- - 主进程，负责启动和管理所有 worker 进程。\n  - 监听端口，接收客户端的连接请求。\n  - 当有请求到达时，负责将请求分配给可用的 worker 进程。\n\n1.  **Worker 进程**： \n\n- - 工作进程，实际处理客户端请求的单元。\n  - 一个 Gunicorn 实例可以有多个 worker 进程，每个 worker 处理一个请求。\n  - Worker 之间是独立的，它们可以并发处理多个请求。\n\n1.  **Worker 类型**： \n\n- - Gunicorn 支持多种 worker 类型，包括 sync（同步）、eventlet、gevent、tornado 等。\n  - 同步 worker 在每个进程中处理一个请求，而异步 worker 可以处理多个请求。\n\n1.  **并发性**： \n\n- - Worker 的数量和并发连接数之间有关系。更多的 worker 可以处理更多的并发请求。\n  - 例如，使用 `-w` 参数可以指定启动的 worker 数量，如 `gunicorn -w 4 myapp:app` 表示启动 4 个 worker 进程。\n\n1.  **负载均衡**： \n\n- - Master 进程通过简单的轮询或其他算法将请求分配给不同的 worker 进程，实现简单的负载均衡。\n  - Gunicorn 还支持其他负载均衡算法，如预先分配请求到不同的 worker。\n\n总体而言，master 进程和多个 worker 进程之间的关系是一种主从关系。Master 进程负责管理和分配任务，而 worker 进程负责实际的请求处理。这种结构使得 Gunicorn 能够更好地利用多核处理器，并提供高性能的 Web 服务。\n\n#### 8.2.4. 执行部署\n\n由此，我们可以使用以下命令，实现最终的部署：\n\n```bash\nnohup gunicorn -w 3 -b 0.0.0.0:9102 --preload predict_online:app &\n```\n\n执行结果：\n\n![WXTeR.png](https://i.imgs.ovh/2023/12/20/WXTeR.png)\n\n后台运行日志文件：\n\n![WXqGp.png](https://i.imgs.ovh/2023/12/20/WXqGp.png)\n\n可见，已成功启动。\n\n### 8.3. 部署效果\n\n使用apifox测试：\n\n![WXNuu.png](https://i.imgs.ovh/2023/12/20/WXNuu.png)\n\n## 9. 源码地址和结构说明\n\n- Gitee开源地址：https://gitee.com/crzzx/comment_moderation\n- 项目代码结构和说明：\n\n```lua\nE:.\n│  .gitignore\n│  comment_test_demo.html # 前端测试代码\n│  example.log\n│  LICENSE\n│  model.py # 模型文件\n│  predict.py # 预测代码\n│  predict_online.py # 预测代码上线版\n│  README.en.md\n│  README.md # 说明文档\n│  test.py # 模型测试代码\n│  textCNN_data.py # 数据集生成代码\n│  train.py # 模型训练代码（cpu版本）\n│  train_gpu.py # 模型训练代码（gpu版本）\n│  __init__.py\n│\n├─data\n│  │  dev.txt # 验证数据集\n│  │  stop_word.txt # 停词表\n│  │  test.txt # 测试数据集\n│  │  train.txt # 验证数据集\n│  │\n│  ├─logs\n│  ├─result\n│  │      log_23121911.txt # 训练日志\n│  │      log_test_23121914.txt # 测试日志\n│  │      test_vec.txt # 测试集词向量\n│  │      textCNN.pkl # 训练好的模型文件\n│  │      train_vec.txt # 训练集词向量\n│  │      valid_vec.txt # 验证集词向量\n│  │      word_list.txt # 词表\n│  │\n│  └─suspect\n│          illegal.txt # 政治敏感词\n│          illegal_char_split.txt\n│          suspected_illegal.txt # 辱骂词\n│\n├─data_process\n│  │  generate_word_list.py # 词表生成代码\n│  │  word2vec.py # 词向量生成代码\n│  │  __init__.py\n│  │\n│  └─__pycache__\n│          word2vec.cpython-39.pyc\n│          __init__.cpython-39.pyc\n│\n└─__pycache__\n        model.cpython-39.pyc\n        textCNN_data.cpython-39.pyc\n        __init__.cpython-39.pyc\n```\n\n## 10. 总结\n\n本文介绍了基于TextCNN文本分类模型的实现和部署，主要解决了新闻文章评论区存在的谩骂言辞问题。以下是文章的主要内容和步骤：\n\n> ### 1. 问题描述：\n>\n> 文章提到新闻文章评论区经常充斥着辱骂言辞，损害了平台声誉和用户体验。为了解决这个问题，需要建立一个自动识别算法，通过模型拦截谩骂评论，提升评论区的品质。\n>\n> ### 2. 算法结构和思路：\n>\n> 文章详细描述了解决问题的算法结构和设计思路，包括：\n>\n> - 预处理阶段：文本清洗和分词处理。\n> - 辱骂违规词检测：建立违规词库，采用多层次匹配策略和动态过滤机制。\n> - 政治敏感词检测：建立敏感词库，进行关联性分析。\n> - TextCNN模型：使用卷积神经网络结构，包括嵌入层、卷积层、全连接层等。\n> - 输出和审核结果：综合判断辱骂违规词检测、政治敏感词检测和TextCNN模型的输出。\n>\n> ### 3. 数据来源：\n>\n> 文章引用了一个参考文章和一个数据来源链接，其中数据来源包括了违规词和政治敏感词。\n>\n> ### 4. 模型选择和训练：\n>\n> 文章选择了TextCNN模型，并提供了模型的结构图和关于嵌入层的详细解释。描述了数据处理、训练和验证的过程，以及模型的保存和测试效果。\n>\n> ### 5. 本地部署：\n>\n> 使用Flask进行本地网络API部署，提供了HTML页面进行简单测试，同时使用Gunicorn处理高并发的服务器。\n>\n> ### 6. 云部署：\n>\n> 介绍了在阿里云轻量应用服务器上的部署环境和配置，并通过Gunicorn进行服务启动。详细说明了Gunicorn的工作原理、worker和负载均衡的概念，以及如何使用Gunicorn进行生产环境部署。\n>\n> ### 7. 代码结构和文件说明：\n>\n> 提供了项目的Gitee开源地址、代码结构和各个文件的功能说明。",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 2,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1721896042632441858",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-20T05:17:16.000+00:00",
        "updateTime": "2023-12-20T10:47:24.000+00:00",
        "user": {
          "id": "1721896042632441858",
          "planetCode": "29240",
          "userName": "南侠（准）",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELkfM4IsxxWrB70flGuaDcq55mDxh8r4DuwOJLuluSmRCH9Pk1MFibry5icVgHtfwMmnYGqT49svVKV3X1wMer2OCC3ob5leZX5lF8HMbPo1Qww/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-11-05T14:14:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-11-07T14:23:02.000+00:00",
          "updateTime": "2023-11-09T14:34:06.000+00:00"
        },
        "tags": [
          "文章",
          "人工智能",
          "项目",
          "Python",
          "开源",
          "算法"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1737073018305273858",
        "title": "要是工作前就知道这个，该多好。",
        "description": null,
        "content": "大家好，我是鱼皮。\n\n前几天直播和大家交流时，有一位小伙伴问我：我现在是外包，如何提升自己？\n\n这让我想到了之前的提问：我的工作天天都是重复的 CRUD，如何提升自己？\n\n其实这两个问题可以统一为：如何在工作中提升自己？\n\n因为每个人的公司、工作情况、环境、职责都不同，所以我们暂且不考虑工作过程中大家得到的成长，我想给大家重点分享的，是我们如何在工作后自主提升？\n\n也就是说，无论工作如何，我们自己能做哪些事情，来帮助自己更快成长呢？\n\n虽然我的工作经验比不上十年的大佬，但算上实习和正式工作，也在公司总共待了快 5 年了，我觉得自己在工作后的成长是非常快的，因此有很多自己的工作提升方法，给大家分享分享。\n\n建议大家直接看视频：https://www.bilibili.com/video/BV1DC4y177sB/\n\n以下文字版，就提炼一些关键内容给大家。\n\n工作后怎么提升自己？\n做好以下 6 件事：\n\n1、每日阅读\n每天读 2 - 3 篇文章，可以是行业趋势、技术干货（自己的工作有关的方向）、经验分享、思维提升等。坚持一年，你就读了将近 1000 篇文章，相当于几十个教程，绝对大有裨益。\n\n文章从哪儿找？\n\n大厂的技术博客：适合想学硬核技术的同学，比如美团技术团队、阿里技术团队\n科技资讯类：量子位、差评、新智元、无敌信息差（我们自己的号）\n经验分享、编程趋势、技术干货：程序员鱼皮、小林 coding、java guide、程序喵、神光的编程笔记、小白 debug、古时的风筝、苏三、阿秀等（很多都是我们一起写文章的朋友）\n2、技术学习\n对程序员来说，一定要持续学习新技术。每天只需要抽不到 1 小时，看 2 - 3 集教程，那么坚持一个月，你就能看完一套课程。\n\n或者每天写 100 行代码，一周一个功能，那么坚持一个月，你就能做好一个项目。\n\n3、复盘总结\n之前也给大家分享过，这是我坚持多年的习惯。\n\n可以尝试做以下几件事：\n\n每天记录自己完成的工作，哪怕贴个需求链接啥的也可以\n每月记录自己这个月重点在做的事情，以及完成的工作、学习的情况等\n每半年或者每完成一个大事，做一个复盘总结。记录自己做这件事情的经历、过程、结果、好和不好的地方，防止后面踩同样的坑。\n4、整理自己的弹药库\n为什么有些人工作五年，感觉还和工作一年一样？\n\n可能就是没有做好 积累 ，把之前的经验忘完了！\n\n所以，积累真的很重要，大家可以从以下几个方面下手：\n\n整理属于自己的 Bug 库，记录你解决过的问题\n整理属于自己的经验库，记录你踩过的坑\n知识碎片积累：把你学过的所有知识点，以碎片的形式进行记录整理，后面要做项目时都可以复用\n软件库（工具库）：整理自己的常用软件、工具，保证自己工作的高效\n5、分享\n只要你做到了上面几件事，那么你一定是有非常多能分享的内容的。\n\n比如：\n\n分享自己的复盘总结和个人经历\n分享自己的弹药库\n分享自己学过的知识点\n帮助别人答疑解惑\n直接把自己之前记录的内容分享出来，就会对别人有帮助，也会收获别人的关注和认可，从而给自己获取正向激励再帮助自己更快地提升，然后再分享更多内容，这是一个非常好的良性循环。\n\n我也是通过这种方式，从自己背过的面试题、再到自己的个人经历、再到自己的项目，依次给大家分享出来，才慢慢收获了更多人的关注，成为了一个博主。谢谢大家！\n\n6、目标拆解\n工作后想持续学习，其实是非常难的，因为我们会本能地担心由于工作的影响，没有更多精力和时间干大事。\n\n这种时候，我们一定要学会将目标拆解。比如你想做一个大项目，可以把它依次拆解为做一个子系统、做一个小的功能、小的模块、学一个技术、看一套课程、看一节教程、看 10 分钟教程。\n\n只要把目标拆解地足够小，做好计划表，然后按照计划，每天坚持执行就好了。\n\n最后还有一点，就是我们要多思考，比如我无法坚持学习，本质的问题是什么？跟改 Bug 一样，先发现问题、再针对性地解决，这才是我们遇到任何困境时的破局战略。\n\n种一棵树最好的时间是十年前，其次是现在。先从上面的任何一件事开始做起，坚持 21 天养成习惯，你就会意识到自己的改变，大家加油，共勉！",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/I8qDpwjP-SCR-20231219-qxjm.jpeg",
        "language": null,
        "viewNum": 24,
        "thumbNum": 5,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T11:30:55.000+00:00",
        "updateTime": "2023-12-20T15:50:33.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3005,
          "coin": 170,
          "followeeNum": 1293,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-12-20T14:52:47.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1737043054050697218",
        "title": "你知道MySQL的CHAR也会变长存储吗",
        "description": "MySQL的CHAR和VARCHAR有什么区别？可以把 CHAR 全部用 VARCHAR 替换吗？",
        "content": "\n\n\n## 前言\n\n一个太常见的面试题是：**MySQL的CHAR和VARCHAR有什么区别**？\n\n如果你的答案只是：定/变长，性能不同，再加个尾部空格处理不同\n\n那么，**这篇文章一定会带给你一些收获**。\n\n看似简单的面试题，也许也会牵扯到许多底层知识，没有什么是理所当然的。\n\n#### 正文开始\n\n最近在MySQL官网上看到这样一句话：\n\n\n>Internally, for nonvariable-length character sets, fixed-length character columns such as CHAR(10) are stored in a fixed-length format. \n\n\n 对于「非变长字符集」，CHAR(10) 以定长格式存储，强调了「非变长字符集」\n\n那么，第一个疑问是，**对于「变长字符集」，CHAR(10) 还是定长存储吗？**\n\n作为佐证，《MySQL实战宝典》中说到：鉴于目前默认字符集推荐设置为 UTF8MB4，所以在表结构设计时，可以把 CHAR 全部用 VARCHAR 替换，底层存储的本质实现一模一样。\n\n所以，第二个疑问是，**CHAR比起VARCHAR真的一无是处吗？**\n\n带着这两个疑问，我们就开始今天的探索了。\n\n> 以下基于MySQL 8.0版本\n\n## CHAR定长，\"定\"的到底是什么\n\n对于CHAR(N)，N 的范围是 0 ~ 255，**指的是字符的个数，而非字节**。这一点非常重要。\n\n> CHAR，VARCHAR，TEXT都是字节；而BINARY，VARBINARY，BLOB都是字符。\n\n而对于「变长字符集」，一个字符对应的字节数是不确定的，而底层存储自然不会关心字符个数，对于VARCHAR而言，行格式的头部元数据也只会存储VARCHAR的字节长度，而非字符长度。\n\n## 我用的是变长字符集吗\n\nMySQL使用`character set`或`charset`来表达字符集。\n\n你可以采用如下命令查看MySQL提供的字符集， 其中`Default collation`代表默认的排序比较规则，`Maxlen`是一个字符对应的最大字节数。\n\n```\nmysql> SHOW CHARSET LIKE 'utf8%';\n--     SHOW CHARACTER SET LIKE 'utf8%'; \n+---------+---------------+--------------------+--------+\n| Charset | Description   | Default collation  | Maxlen |\n+---------+---------------+--------------------+--------+\n| utf8    | UTF-8 Unicode | utf8_general_ci    |      3 |\n| utf8mb4 | UTF-8 Unicode | utf8mb4_0900_ai_ci |      4 |\n+---------+---------------+--------------------+--------+\n```\n\nMySQL默认的字符集是 `utf8mb4` ，排序规则为 `utf8mb4_0900_ai_ci`，除非你在创建数据库，表，字段时显式指定，否则都采用这个默认值，而`utf8mb4`就是一个变长字符集。\n\n你还可以通过`SHOW CREATE TABLE`命令查看具体某一列的字符集。\n\n``` sql\nSHOW CREATE TABLE [表名称];\n```\n\n为了能够存储某些emoji表情，许多字段都会采取 `utf8mb4`作为字符集，因此大部分情况，字符串字段都会采用变长字符集。\n\n## 当「定长字符」遇上「变长字节」\n\n那现在问题就来了，CHAR是定字符数，但字符集导致了字符对应的字节数是不定的。因此：\n\n在「变长字符集」下，CHAR并非定字节存储，而底层存储只认字节不认字符，这该怎么办呢？\n\n这就取决于「存储引擎」和「行格式」的具体实现了。\n\n> 下面都基于InnoDB存储引擎\n\n### Redundant行格式\n\n一种很好想到的简单的做法是：化变为不变。即我们还是希望CHAR是定字节存储，但又要符合用户最大字符数的预期，那我们就让CHAR(N)的字节数为「字符集的一个字符对应的最大字节数*N」。\n\n#### 没用上的字节如何填充\n\n答案是用空格填充，直至CHAR(N)的实际字节数达到「字符集的一个字符对应的最大字节数*N」。\n\n-   存储 CHAR 值时，会用空格将其填充到指定的长度。\n-   查询 CHAR 值时，除非启用 `PAD_CHAR_TO_FULL_LENGTH SQL` 模式，否则会**删除尾部空格**。\n\n> 这与VARCHAR不同，VARCHAR在存储和查询时，会保留尾部空格，除非超过列的最大长度。\n>\n> 下面用官网的例子来理解一下：\n>\n> ``` sql\n> -- SQL:\n> CREATE TABLE vc (v VARCHAR(4), c CHAR(4));\n> INSERT INTO vc VALUES ('ab  ', 'ab  ');\n> -- RESULT:\n> SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;\n> +---------------------+---------------------+\n> | CONCAT('(', v, ')') | CONCAT('(', c, ')') |\n> +---------------------+---------------------+\n> | (ab  )              | (ab)                |\n> +---------------------+---------------------+\n> ```\n\n### Compact家族行格式\n\n> Dynamic 和 Compressed都是Compact衍生而来，Dynamic是MySQL8.0 InnoDB的默认行格式。因此，此处介绍的特性对如今广泛使用的 Dynamic 同样适用。\n\n在InnoDB的Compact行格式家族中，对变长字符集的CHAR有特殊优化：\n\n-   如果CHAR(N)的实际字节数小于等于N，不会在尾部追加空格直到达到「字符集的一个字符对应的最大字节数*N」（以utf8mb4为例，就是4 * N），而是追加到N，就停止。\n-   如果CHAR(N)的实际字节数大于N，不会在尾部追加空格\n\n#### 为什么仍然至少为N\n\n即便在Compact紧凑行格式下，CHAR都至少占N个字节，既然都已经是变长了，为啥还至少要N个字节呢？官方给出的解释是这样的：\n\n\n>Reserving the minimum space N in many cases enables column updates to be done in place without causing index page fragmentation. \n\n\n即在大部分情况下，预留N个字节能够避免「索引页分裂」问题。但继续说这个就跑题了，感兴趣的可以去查一下\n\n## 测试：验证结论\n\n以上都是理论，为了证明我不是在胡说八道，接下来搞点实战：\n\n先来建个表，注意这里用了NOT NULL：\n\n``` sql\nCREATE TABLE `char_test` (\n  `name` char(5) NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\n```\n\n插入三条数据：\n\n``` sql\n INSERT INTO char_test(name) values ('\uD83D\uDE0A\uD83D\uDE0A\uD83D\uDE0A\uD83D\uDE0A\uD83D\uDE0A');\n INSERT INTO char_test(name) values ('\uD83D\uDE0A\uD83D\uDE0A\uD83D\uDE0A\uD83D\uDE0A\uD83D\uDE0A');\n INSERT INTO char_test(name) values ('\uD83D\uDE0A\uD83D\uDE0A\uD83D\uDE0A\uD83D\uDE0A');\n```\n\n> \uD83D\uDE0A的十六进制表达为：F0 9F 98 8A\n\n接下来找到数据文件：\n\n``` sql\n-- 通过这个命令拿到数据文件所在的目录\nshow variables like '%datadir%';\n```\n\n搜索F0 9F 98 8A\n\n\n\n![image-20231125221143591.png](https://pic.code-nav.cn/post_picture/1631488212859977730/qfdfRsBB-image-20231125221143591.png)\n为了方便你观察，我把它第二条数据和第三条数据单独拎出来看以下：\n\n\n第二条数据：\n\n```\n14 0000 1800 2d00 0000 0013 9400 0000 0338 7782 0000 00a4 0110 \n// 5个 F0 9F 98 8A\nf09f 988a f09f 988a f09f 988a f09f 988a f09f 988a\n```\n\n第三条数据：\n\n```\n1000 0020 ff98 0000 0000 1395 0000 0003 387c 8100 0000 a701 10 \n// 4个 F0 9F 98 8A\nf0 9f98 8af0 9f98 8af0 9f98 8af0 9f98 8a\n```\n\n看不懂？让我们简单看一下Dynamic行格式的组成（如果了解可以跳过）\n\n#### Dynamic行格式的组成\n\n##### 1、变长字段的长度\n\n如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；\n\n##### 2、NULL\n\n因为是非NULL，所以不存在\n\n##### 3、头信息\n\n固定5字节\n\n##### 4、隐式数据\n\n由于没有指定主键，MySQL隐式生成6个字节的row_id，以及6个字节的trx_id和7个字节的roll_pointer 。\n\n##### 5、实际数据\n\n最后就是列的实际值。\n\n整体上看就是下面这样（网上找来的图，侵删）\n\n\n\n![COMPACT.drawio.png](https://pic.code-nav.cn/post_picture/1631488212859977730/lnvlC12y-COMPACT.drawio.png)\n### 重新审视实验结果\n\n有了上面的基础，相信大家就能看懂了。\n\n我们观察到第一个位置的14和10，十六进制表达，转为十进制，即为20和16。\n\n隐式主键为 0000 0000 1394 和 0000 0000 1395，后跟13字节的trx_id 和 roll_ptr。实验结果符合理论基础。\n\n至此，我们可以确定：\n\n**CHAR也被InnoDB当作变长字段，使用了「行格式中的变长字段长度列表」来表达CHAR的字节长度，即length()函数的返回值。**\n\n因此，现在可以说：**对于变长字符集，Dynamic行格式的InnoDB，CHAR和VARCHAR的底层存储是一样的。**\n\n#### 那性能呢\n\n即便底层存储是一样的，也不代表性能一定相同。\n\n经过笔者的可能不太精确的测试，得到的结论是：VARCHAR与CHAR的速度是差不多的。\n\n当然在字节数不同的情况下，二者的性能会各有起伏，但总的来说，十分接近。\n\n感兴趣的读者可以自己尝试一下，需要注意Buffer Pool的存在，由于Buffer Pool的缓存预热功能，可能即便重启MySQL，仍然会有部分数据页存在在Buffer Pool中，并且MySQL8.0并不提供任何能够清空Buffer Pool的命令\n\n> 包括`innodb_buffer_pool_size`设为0，`SELECT SQL_NO_CACHE ...`，`FLUSH TABLES` 等方案都是不行的\n\n### 小结\n\n在MySQL8.0，使用InnoDB引擎，及Dynamic行格式，并且采取变长字符集时，在存储底层CHAR是变长的。\n\n有时，CHAR占用的实际空间可能不仅会大于VARCHAR，而且在性能上慢于VARCHAR。\n\n因此，在绝大多数情况下，VARCHAR可以替代CHAR。",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 5,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1631488212859977730",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T09:31:51.000+00:00",
        "updateTime": "2023-12-20T07:50:36.000+00:00",
        "user": {
          "id": "1631488212859977730",
          "planetCode": "17561",
          "userName": "山山水水",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/Rzm68moWz4LwOia4T13J8XclX0kLo33VIDTB3XypyYC7VztnJDNkLraJKY5PeiaIlXWV8ibm6qC28bJpkgtVfAqFg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-03-02T04:52:54.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-03-03T02:54:36.000+00:00",
          "updateTime": "2023-03-03T04:52:53.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1736915166638923778",
        "title": "【Java基础】反射基础&简单模拟SpringMVC",
        "description": "【Java基础】反射基础&简单模拟SpringMVC",
        "content": "\n# 一.概述\n\n反射是指对于**任何一个Class类**，在**运行的时候**都可以**直接得到这个类全部成分**，使得我们可以**动态操作**Java代码，同时反射也**破坏了Java的封装性**。\n\n例如：在运行时,可以直接得到这个类的构造器对象（`Constructor`）、成员变量对象（`Field`）、成员方法对象（`Method`），不管是否为私有，这种**运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制**。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/dqxnMqcy-image.png)\n\n**反射的关键和核心思想**：必须先获取编译后的Class类对象，然后就可以分析类对象中的全部成分并进行一些操作。\n\n```java\nHelloWorld.java -> javac -> HelloWorld.class\n// 获取类对象\nClass c = HelloWorld.class;\n// 获取其他类中的各个成分....\n```\n\n**反射的用途**：反射为绝大部分Java框架的底层实现原理。它常常被用于**开发各种具有通用性的框架或者工具**。\n\n# 二.获取类对象\n\n## (1) 引入\n\n反射的第一步就是先获取Class类对象，然后我们便可以基于获取的类对象解析类中的全部成分。我们有三种方式可以获取类对象：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/IMmRhlGd-image.png)\n\n\n三种方式对比显然直接通过`类名.class`方式获取最简单，但我们依旧需要看使用场景选择不同的方式。例如：假如我们需要获取方法参数传递对象的类对象，只能使用`对象.getClass()`。\n\n我们先创建一个学生类，用于获取类对象。\n\n```java\n// 反射学习\npackage relate;\n\npublic class Student {\n}\n```\n\n## (2) 第一种方式\n\n我们可以通过Class类的一个静态方法`forName(\"全限名\")`获取类对象\n\n```java\npackage relate;\n\npublic class Test {\n    public static void main(String[] args) throws ClassNotFoundException {\n        // 获取类对象\n        Class c = Class.forName(\"relate.Student\");\n        // 打印类对象，也可以直接通过getSimpleName获取类名\n        System.out.println(c+\"====>\"+c.getSimpleName());\n    }\n}\n\n// 打印结果\n// class relate.Student====>Student\n```\n\n**全限名**：可以看作是**包名+类名**。\n\n## (3) 第二种方式\n\n我们也可以通过一种更为简单的方式获取：`类名.class`。\n\n```java\npackage relate;\n\npublic class Test {\n    public static void main(String[] args) throws ClassNotFoundException {\n        // 获取类对象\n        Class c = Student.class;\n        // 打印类对象，，也可以直接通过getSimpleName获取类名\n        System.out.println(c+\"====>\"+c.getSimpleName());\n    }\n}\n// 打印结果相同\n// class relate.Student====>Student\n```\n\n## (4) 第三种方式\n\n此外我们还可以通过Object类中的getClass方法获取类对象：`对象.getClass()`\n\n```java\npackage relate;\n\npublic class Test {\n    public static void main(String[] args) throws ClassNotFoundException {\n        // 获取类对象\n        Student student = new Student();\n        Class c = student.getClass();\n        // 打印类对象，，也可以直接通过getSimpleName获取类名\n        System.out.println(c+\"====>\"+c.getSimpleName());\n    }\n}\n// 打印结果也相同\n// class relate.Student====>Student\n```\n\n我们已经获取了类对象，接下来便可以逐步解析类对象中的各个成分了，尽管类中存在一些私有的成分，但我们仍然可以获取到，也就是说可以**破坏封装性**\n\n# 三.获取构造器对象\n\n## (1) 引入\n\n我们可以通过反射获取类对象的任意构造器，然后再创建对象，尽管有些类的构造器是私有的，但并不妨碍我们基于此创建对象。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/TSsahVJA-image.png)\n\n\nClass类提供了一些方法供我们获取构造器对象：\n\n| 方法                                                         | 说明                                                        |\n| ------------------------------------------------------------ | ----------------------------------------------------------- |\n| Constructor<?>[]  getConstructors()                          | 返回**所有**构造器对象的数组（**只能拿public的**）          |\n| Constructor<?>[]  getDeclaredConstructors()                  | 返回**所有**构造器对象的数组，**存在(包括private)就能拿到** |\n| Constructor<T>  getConstructor(Class<?>...  parameterTypes)  | 返回**单个**构造器对象，**只能拿public的**                |\n| Constructor<T>  getDeclaredConstructor(Class<?>...  parameterTypes) | 返回**单个**构造器对象，**存在包括private**都能拿到       |\n\n## (2) 获取多个构造器\n\n### (2.1) 公有构造器\n\n通过`getConstructors`方法我们只能获取所有的公有构造器：\n\n```java\n//    public Student() {\n//    }\n\n//    public Student(String name, int age) {\n//        this.name = name;\n//        this.age = age;\n //   }\n\npublic class Test {\n    public static void main(String[] args) {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取公有public构造器对象\n        Constructor[] constructors = c.getConstructors();\n        // 3.打印结果\n        for (Constructor constructor : constructors) {\n            System.out.println(constructor);\n        }\n    }\n}\n\n// 可以看到我们声明的两个构造器\n// public relate.Student()\n// public relate.Student(java.lang.String,int)\n```\n\n假如我们将带参的构造器改为私有的：\n\n```java\nprivate Student(String name, int age) {\n    this.name = name;\n    this.age = age;\n}\n```\n\n再次运行发现我们只能获取到公有的无参构造器，而私有的带参构造器则无法获取到\n\n```java\n// 打印结果\n// public relate.Student()\n```\n\n### (2.2) 任意构造器\n\n我们只需要使用`getDeclaredConstructors`即可获取所有构造器，包括私有构造器，这也是我们常用的。用法与上述类似：\n\n```java\n//    public Student() {\n//    }\n\n//    private Student(String name, int age) {\n//        this.name = name;\n//        this.age = age;\n //   }\n\npublic class Test {\n    public static void main(String[] args) {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取所有存在的构造器对象\n        Constructor[] constructors = c.getDeclaredConstructors();\n        // 3.打印结果\n        for (Constructor constructor : constructors) {\n            System.out.println(constructor);\n        }\n    }\n}\n// 打印结果\n// public relate.Student()\n// private relate.Student(java.lang.String,int)\n```\n\n## (3) 获取单个构造器\n\n我们也可以根据构造器参数的类型与数量获取单个构造器。\n\n### (3.1) 公有构造器\n\n我们可以通过`getConstructor`获取单个构造器，与上述类似，只能获取公有构造器\n\n```java\n//    public Student() {\n//    }\n\n//   public Student(String name, int age) {\n//       this.name = name;\n//        this.age = age;\n//   }\n\npackage relate;\n\nimport java.lang.reflect.Constructor;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取单个公有构造器对象\n        Constructor constructor1 = c.getConstructor();  // 无参直接方法名获取\n        Constructor constructor2 = c.getConstructor(String.class, int.class); // 带参数需要指定每个参数类型\n        // 3.打印结果\n        System.out.println(\"无参构造器===》\" + constructor1);\n        System.out.println(\"带参构造器===》\" + constructor2);\n    }\n}\n// 打印结果\n// 无参构造器===》public relate.Student()\n// 带参构造器===》public relate.Student(java.lang.String,int)\n```\n\n### (3.2) 任意构造器\n\n我们还可以通过`getDeclaredConstructor`获取单个任意构造器\n\n```java\n//    public Student() {\n//    }\n\n//    public Student(String name, int age) {\n//        this.name = name;\n//        this.age = age;\n//   }\n\npackage relate;\n\nimport java.lang.reflect.Constructor;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取任意构造器对象\n        Constructor constructor1 = c.getDeclaredConstructor(); // 无参直接方法名获取\n        Constructor constructor2 = c.getDeclaredConstructor(String.class, int.class); // 带参数需要指定每个参数类型\n        // 3.打印结果\n        System.out.println(\"无参构造器===》\" + constructor1);\n        System.out.println(\"带参构造器===》\" + constructor2);\n    }\n}\n// 打印结果\n// 无参构造器===》public relate.Student()\n// 带参构造器===》private relate.Student(java.lang.String,int)\n```\n\n## (4) 创建对象\n\n我们可以通过如下方法利用构造器对象创建对象。\n\n| 方法                                      | 说明                                                        |\n| ----------------------------------------- | ----------------------------------------------------------- |\n| T newInstance(Object...  initargs)        | 根据指定的构造器创建对象（若构造器为private需要先取消检查） |\n| public  void setAccessible(boolean  flag) | 设置为true,表示取消访问检查，进行暴力反射 ，**无视private** |\n\n### (4.1) 基于公有构造器\n\n我们可以基于获取到的构造器对象来创建对象。\n\n```java\n//    public Student() {\n//    }\n\npackage relate;\n\nimport java.lang.reflect.Constructor;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取构造器对象\n        Constructor constructor = c.getDeclaredConstructor();\n\n        // 3.根据无参构造器创建对象，0个参数\n        Student student = (Student) constructor.newInstance();\n        System.out.println(student);\n    }\n}\n// 打印结果\n// Student{name='null', age=0}\n```\n\n### (4.2) 基于私有构造器\n\n尽管我们可以获取到私有构造器，但是通过其创建对象时会发现程序会抛出异常，这时因为我们还要通过`setAccessible`打开权限。这也暴露了我们使用单例模式并不能一定保证只有一个对象。\n\n```java\n//   private Student(String name, int age) {\n//       this.name = name;\n//        this.age = age;\n//   }\n\npackage relate;\n\nimport java.lang.reflect.Constructor;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取构造器对象\n        Constructor constructor = c.getDeclaredConstructor(String.class, int.class);\n\n        // 3.打开权限\n        constructor.setAccessible(true);\n\n        // 4.创建对象\n        Student student = (Student) constructor.newInstance(\"观止\", 19);\n        System.out.println(student);\n    }\n}\n// 打印结果\n// Student{name='观止', age=19}\n```\n\n# 四.获取成员变量对象\n\n## (1) 引入 \n\n我们同样可以通过反射获取类对象的任意成员变量并进行赋值或获取值。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/7uiHEEfK-image.png)\n\n\nClass类也提供了一些方法供我们获取成员变量对象：\n\n| 方法                                  | 说明                                         |\n| ------------------------------------- | -------------------------------------------- |\n| Field[]  getFields()                  | 返回所有成员变量对象的数组（只能拿public的） |\n| Field[]  getDeclaredFields()          | 返回所有成员变量对象的数组，存在就能拿到     |\n| Field  getField(String  name)         | 返回单个成员变量对象（只能拿public的）       |\n| Field  getDeclaredField(String  name) | 返回单个成员变量对象，存在就能拿到           |\n\n需要注意的是：\n\n- `getFields`将返回所有的公共字段，**包括从父类中继承来的公共字段**。\n- `getDeclaredFields`则**只返回自身**包含的全部字段。\n\n## (2) 获取多个成员变量\n\n### (2.1) 公有成员变量\n\n可以通过`getFields`获取所有公有成员变量\n\n```java\n //   public String name;\n //   private int age;\n \nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取公有成员变量\n        Field[] fields = c.getFields();\n        // 3. 遍历打印结果\n        for (Field field : fields) {\n            System.out.println(field + \"===>\" + field.getName());\n        }\n    }\n}\n// 打印结果\n// public java.lang.String relate.Student.name ===> name ===> class java.lang.String\n```\n\n### (2.2) 任意成员变量\n\n可以通过`getDeclaredFields`获取所有任意成员变量\n\n```java\n //   public String name;\n //   private int age;\n\npackage relate;\n\nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取任意成员变量\n        Field[] fields = c.getDeclaredFields();\n        // 3. 遍历打印结果\n        for (Field field : fields) {\n            System.out.println(field + \" ===> \" + field.getName());\n        }\n    }\n}\n// 打印结果\n// public java.lang.String relate.Student.name ===> name ===> class java.lang.String\n// private int relate.Student.age ===> age ===> int\n```\n\n## (3) 获取单个成员变量\n\n### (3.1) 公有成员变量\n\n可以通过`getField`获取单个公有成员变量\n\n```java\npackage relate;\n\nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.根据名称获取公有成员变量\n        Field name = c.getField(\"name\");\n        // 3.打印结果\n        System.out.println(name + \" ===> \" + name.getName()+ \" ===> \" + name.getType());\n    }\n}\n// 打印结果\n// public java.lang.String relate.Student.name ===> name ===> class java.lang.String\n```\n\n### (3.2) 任意成员变量\n\n可以通过`getDeclaredField`获取单个任意成员变量\n\n```java\npackage relate;\n\nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.根据名称获取任意成员变量\n        Field age = c.getDeclaredField(\"age\");\n        // 3.打印结果\n       System.out.println(age + \" ===> \" + age.getName()+ \" ===> \" + age.getType());\n    }\n}\n// 打印结果\n// private int relate.Student.age ===> age ===> int\n```\n\n## (4) 赋值&获取值\n\n我们可以获取或修改对象的字段值，尽管有限字段是私有不对外暴露的，但依旧可以通过反射进行操作。\n\n| 方法                                  | 说明     |\n| ------------------------------------- | -------- |\n| void  set(Object obj, Object value)： | 赋值     |\n| Object  get(Object obj)               | 获取值。 |\n\n我们必须先创建对象，再进行操作，因为不基于对象，对象值是毫无意义的。\n\n```java\npackage relate;\n\nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        \n        // 2.获取成员变量\n        Field name = c.getDeclaredField(\"name\");\n        Field age = c.getDeclaredField(\"age\");\n        \n        // 3. 赋予访问私有字段权限\n        age.setAccessible(true);\n        \n        // 3.给字段赋值\n        Student student = new Student();\n        name.set(student, \"观止\");\n        age.set(student, 20);\n        \n        // 打印对象并获取字段值\n        System.out.println(student + \"===>\" + name.get(student) + \"===>\" + age.get(student));\n    }\n}\n\n// 打印结果\n// Student{name='观止', age=20}===>观止===>20\n```\n\n我们以前都是通过`对象.getXX`获取字段值和`对象.setXX()`设置值，而通过反射则是以`XX.get(对象)`获取字段值和`xx.set(对象，X)`设置值，刚好相反。\n\n# 五.获取方法对象\n\n## (1) 引入\n\n我们同样可以通过反射获取类对象的任意方法对象并且手动进行触发操作。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/2bgB0Seg-image.png)\n\n\nClass类也提供了一些方法供我们获取方法对象：\n\n| 方法                                                         | 说明                                         |\n| ------------------------------------------------------------ | -------------------------------------------- |\n| Method[]  getMethods()                                       | 返回所有成员方法对象的数组（只能拿public的） |\n| Method[]  getDeclaredMethods()                               | 返回所有成员方法对象的数组，存在就能拿到     |\n| Method  getMethod(String  name, Class<?>... parameterTypes)  | 返回单个成员方法对象（只能拿public的）       |\n| Method  getDeclaredMethod(String  name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到           |\n\n需要注意的是：\n\n- `getMethods`将返回所有的公共方法，**包括从父类中继承来的公共方法**。\n- `getDeclaredMethods`则**只返回自身**包含的全部方法。\n\n我们为学生类添加三个方法用于测试：\n\n```java\n    public void run() {\n        System.out.println(\"invoke public run...\");\n    }\n\n    public void sing(String name) {\n        System.out.println(\"sing \" + name);\n    }\n\n    private void dance() {\n        System.out.println(\"invoke private dance...\");\n    }\n\n    private void eat(String name) {\n        System.out.println(\"eat \" + name);\n    }\n```\n\n## (2) 获取多个方法\n\n### (2.1) 公有方法\n\n我们可以通过`getMethods`获取类中所有的方法**包括其父类**中的方法。\n\n```java\npackage relate;\n\nimport java.lang.reflect.Method;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取多个成员方法\n        Method[] methods = c.getMethods();\n        // 3.遍历\n        for (Method method : methods) {\n\t\tSystem.out.println(\"方法名称：\"+method.getName()+\",返回值类型：\"+method.getReturnType()+\",参数个数：\"+method.getParameterCount());\n        }\n    }\n}\n// 除了Student类中的方法，其继承自Object的方法也会打印\n// 方法名称：run，返回值类型：void，参数个数：0\n// 方法名称：toString，返回值类型：class java.lang.String，参数个数：0\n// 方法名称：wait，返回值类型：void，参数个数：2\n// 方法名称：wait，返回值类型：void，参数个数：1\n// 方法名称：wait，返回值类型：void，参数个数：0\n// 继承自Object.....\n```\n\n### (2.2) 任意方法\n\n我们可以看到上述虽然获取到了很多方法，但并没有获取到私有的两个方法，我们可以通过`getDeclaredMethods`获取任意方法。\n\n```java\npackage relate;\n\nimport java.lang.reflect.Method;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取多个成员方法\n        Method[] methods = c.getDeclaredMethods();\n        // 3.遍历\n        for (Method method : methods) {\n            System.out.println(\"方法名称：\"+method.getName()+\"，返回值类型：\"+method.getReturnType()+\"，参数个数：\"+method.getParameterCount());\n        }\n    }\n}\n// Student类中声明的任意方法\n// 方法名称：run，返回值类型：void，参数个数：0\n// 方法名称：toString，返回值类型：class java.lang.String，参数个数：0\n// 方法名称：dance，返回值类型：void，参数个数：0\n// 方法名称：eat，返回值类型：void，参数个数：1\n```\n\n## (3) 获取单个方法\n\n### (3.1) 公有方法\n\n我们可以通过`getMethod`获取单个公有方法对象。\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取公有成员方法\n        Method run = c.getMethod(\"run\"); // 无参直接方法名获取\n        Method sing = c.getMethod(\"sing\", String.class); // 带参数需要指定每个参数类型\n\n        // 3.打印结果\n        System.out.println(\"方法名称：\"+run.getName()+\"，返回值类型：\"+run.getReturnType()+\"，参数个数：\"+run.getParameterCount());\n        System.out.println(\"方法名称：\"+sing.getName()+\"，返回值类型：\"+sing.getReturnType()+\"，参数个数：\"+sing.getParameterCount());\n    }\n}\n\n// 打印结果\n// 方法名称：run，返回值类型：void，参数个数：0\n// 方法名称：sing，返回值类型：void，参数个数：1\n```\n\n### (3.2) 私有方法\n\n我们可以通过`getMethod`获取任意方法对象。\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取私有成员方法\n        Method dance = c.getDeclaredMethod(\"dance\"); // 无参直接方法名获取\n        Method eat = c.getDeclaredMethod(\"eat\", String.class); // 带参数需要指定每个参数类型\n\n        // 3.打印结果\n        System.out.println(\"方法名称：\"+dance.getName()+\"，返回值类型：\"+dance.getReturnType()+\"，参数个数：\"+dance.getParameterCount());\n        System.out.println(\"方法名称：\"+eat.getName()+\"，返回值类型：\"+eat.getReturnType()+\"，参数个数：\"+eat.getParameterCount());\n    }\n}\n// 打印结果\n// 方法名称：dance，返回值类型：void，参数个数：0\n// 方法名称：eat，返回值类型：void，参数个数：1\n```\n\n## (4) 触发方法\n\n我们可以触发获取到的方法，不管它是否为私有方法。\n\n| 方法                                      | 说明                                                         |\n| ----------------------------------------- | ------------------------------------------------------------ |\n| Object invoke(Object obj, Object... args) | **参数一**：通过对象调用该方法  **参数二**：调用方法的传递的参数（如果没有可以不写）  **返回值**：方法的返回值（如果没有可以不写） |\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取私有成员方法\n        Method run = c.getDeclaredMethod(\"run\");\n        Method eat = c.getDeclaredMethod(\"eat\", String.class);\n\n        // 2.1 获取执行私有方法权限\n        eat.setAccessible(true);\n\n        // 3.创建对象用于触发方法\n        Student student = new Student();\n        // 4. 触发方法\n        Object runRes = run.invoke(student); // 没返回值runRes为null\n        Object eatRes = eat.invoke(student, \"水果\");  // 没返回值eatRes为null\n\n        // 3.打印结果\n        System.out.println(\"runRes===>\" + runRes + \"，eatRes===>\" + eatRes);\n    }\n}\n// 打印结果\n// invoke public run...\n// eat 水果\n// runRes===>null，eatRes===>null\n```\n\n# 六.作用\n\n## (1) 泛型擦除\n\n由于反射是作用在**运行时**的技术，而泛型**只在编译阶段可以约束**只能操作某种数据类型，使用**反射泛型将不能产生对我们产生约束**，此时就相当于泛型被擦除了。\n\n\n\n**例如**：我们编写如下代码时，往集合添加Integer类型数据不会产生报错，而添加其他类型数据将无法通过编译。\n\n```java\nArrayList<Integer> list = new ArrayList<>();\nlist.add(100);   // 合法\n// list.add(“观止\"); // 产生编译错误\nlist.add(99);  // 合法\n```\n\n而使用反射操作，此时集合的泛型将不能产生约束，**可以为集合存入其他任意类型的元素的**。泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了。\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n\n        // 1.创建对象\n        ArrayList<Integer> list = new ArrayList<>();\n        // 尝试添加\n        list.add(666);\n//        list.add(\"观止\"); // 报错\n        // 2.获取类对象\n        Class listClass = list.getClass();\n        // 3.获取add方法\n        Method add = listClass.getDeclaredMethod(\"add\", Object.class);\n        // 4.添加其他类型元素\n        add.invoke(list,\"观止\");\n        add.invoke(list,999);\n        // 5.打印查看数据是否添加\n        System.out.println(list);\n    }\n}\n// 打印结果\n// [666, 观止, 999]\n```\n\n可以看到外面不单单存在Integer类型数据，还存在它所不允许的String类型数据，跳过了泛型对我们的约束作用。\n\n## (2) 通用框架的底层原理\n\n几乎所有的框架实现都用到了反射技术，使用反射可以帮助我们很好的处理**多变**的情况。\n\n**例如**：给你任意一个对象，在不清楚对象字段的情况下，可以把对象的字段名称和对应值存储到文件中去。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/ujfI0xV1-image.png)\n\n\n不使用反射显然我们无法对可变的情况进行固定的操作，更别说获取一些不对外暴露的私有字段。使用反射却能很好的帮助我们解决这种情况。\n\n```java\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        Student s = new Student(\"彭于晏\", 40, '男', 177.5, \"男星\");\n        printAllFiled(s);\n        Teacher t = new Teacher(\"观止\", 6000);\n        printAllFiled(t);\n\n    }\n\n    public static void printAllFiled(Object obj) throws IllegalAccessException {\n        // 1.获取类对象\n        Class objClass = obj.getClass();\n        // 2. 获取类名打印横幅\n        System.out.println(\"========\" + objClass.getSimpleName() + \"========\");\n        // 3.获取所有字段\n        Field[] fields = objClass.getDeclaredFields();\n        // 4.打印所有字段以及字段值\n        for (Field field : fields) {\n            // 5. 允许访问操作私有字段\n            field.setAccessible(true);\n            System.out.println(field.getName() + \" = \" + field.get(obj));\n        }\n    }\n}\n\n```\n\n可以看到即使我们的类结构存在差异它也能正常的获取并打印数值。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/BjmODyCy-image.png)\n## (3) 简单模拟SpringMVC\n我们知道使用SpringMVC大幅度的简化了我们使用Servlet开发需要重复写大量类和重复代码的烦恼。我们使用反射加上上文所学的[自定义注解](https://blog.csdn.net/m0_66570338/article/details/129942054)可以简单模拟一下SpringMVC中`@RequestMapping`的功能。\n\n- 导入servlet所需要的坐标并进行一些配置\n\n```xml\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>4.0.1</version>\n            <scope>provided</scope>\n        </dependency>\n        <!--    确保能获取方法参数列表真实名称-->\n    <build>\n        <plugins>\n            <plugin>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.8.1</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                    <encoding>utf8</encoding>\n                    <compilerArgs>\n                        <arg>-parameters</arg>\n                    </compilerArgs>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n```\n- 自定义`@RequestMapping`注解\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RequestMapping {\n    String value();\n}\n```\n- 创建一个Servlet简单模拟在SpringMVC中配置请求路径的写法\n\n```java\n// 接收以AppServlet开头的任意路径\n@WebServlet(\"/AppServlet/*\")\npublic class AppServlet extends HttpServlet {\n\n    // mvc请求路径 -> 方法对象\n    Map<String, Method> hashmap = new HashMap<>();\n\n    // 获取并加载所有存在注解的映射路径以及方法对象\n    @Override\n    public void init() {\n        // 1. 获取类对象\n        Class<AppServlet> appServletClass = AppServlet.class;\n        // 2. 获取所有方法\n        Method[] methods = appServletClass.getDeclaredMethods();\n        // 3. 保存所有路径\n        for (Method method : methods) {\n            // 判断是否存在注解\n            boolean present = method.isAnnotationPresent(RequestMapping.class);\n            if (present) {\n                // 将路径+方法对象存入map\n                RequestMapping annotation = method.getAnnotation(RequestMapping.class);\n                String path = annotation.value();\n                hashmap.put(path, method);\n            }\n        }\n    }\n\n \t// 作为中转站，根据请求路径转发到对应注解匹配的路径\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setCharacterEncoding(\"utf-8\");    //设置 HttpServletResponse使用utf-8编码\n        response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\");    //通知浏览器使用utf-8解码\n        // 0.获取请求路径\n        String requestURI = request.getRequestURI();\n        String targetPath = requestURI.substring(\"/MyMVC_war/AppServlet\".length());\n        // 获取请求参数集合\n        ArrayList list = new ArrayList();\n        Map<String, String[]> parameterMap = request.getParameterMap();\n        // 3. 创建对象用于触发方法\n        AppServlet appServlet = new AppServlet();\n        // 判断请求路径是否存在\n        if (hashmap.containsKey(targetPath)) {\n            // 存在调用方法\n            try {\n                Method method = hashmap.get(targetPath);\n                Object res = \"\";\n                // 判断方法是否带参数\n                if (method.getParameterCount() == 0) {\n                    // 无参\n                    res = method.invoke(appServlet);\n                } else {\n                    // 带参\n                    for (Parameter parameter : method.getParameters()) {\n                        // 类型转换适配\n                        String value = parameterMap.get(parameter.getName())[0];\n                        if (value == null) {\n                            throw new RuntimeException(\"参数名称不匹配\");\n                        }\n                        list.add(convert(parameter.getType(), value));\n                    }\n                    // 参数传递\n                    res = method.invoke(appServlet, list.toArray());\n                }\n                response.getWriter().write(res.toString());\n            } catch (Exception e) {\n                throw new RuntimeException(\"server error 500!\", e);\n            }\n        } else {\n            response.getWriter().write(\"路径不存在\");\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        doGet(request, response);\n    }\n\n    // 将获取到的参数转为指定类型\n    public static Object convert(Class<?> type, String str) {\n        // 整型\n        if (type.isAssignableFrom(int.class) || type.isAssignableFrom(Integer.class)) {\n            return Integer.valueOf(str);\n        } else if (type.isAssignableFrom(double.class) || type.isAssignableFrom(Double.class)) {\n            // 浮点型\n            return Double.valueOf(str);\n        } else {\n            // 字符串\n            return str;\n        }\n    }\n\n\t// 模拟SpringMVC写法 \n    @RequestMapping(\"/add\")\n    private Object add(String name, int age) {\n        return \"add invoke ==> \" + name + \" ==> \" + age;\n    }\n\n    @RequestMapping(\"/delete\")\n    private Object delete(int id) {\n        return \"delete invoke:\" + id;\n    }\n\n    @RequestMapping(\"/update\")\n    private Object update() {\n        return \"update invoke\";\n    }\n\n    @RequestMapping(\"/select\")\n    private Object select() {\n        return \"select invoke\";\n    }\n\n}\n```\n- 通过postman进行测试\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/PkNy9muL-image.png)\n可以看到我们成功通过反射将请求路径映射到注解所对应的方法中\n\n\n\n\n\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619305100524748802/PDX2irG3-R-C.png",
        "language": null,
        "viewNum": 12,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619305100524748802",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T01:03:40.000+00:00",
        "updateTime": "2023-12-19T13:06:28.000+00:00",
        "user": {
          "id": "1619305100524748802",
          "planetCode": "6872",
          "userName": "观止.",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/OYu6LaaicHd8CDShMPqharTUTck82BzOggVOzdsF3AqPyVMRjAjEicQpvpQTQAeUFOvnsPuHLBTYNDWMgsg0r5LQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": -4,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 9,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-01-28T13:18:24.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-28T12:03:15.000+00:00",
          "updateTime": "2023-12-20T09:18:47.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1736913669855404033",
        "title": "【Java基础】注解详述&简单模拟Junit框架",
        "description": "【Java基础】注解详述&简单模拟Junit框架",
        "content": "\n# 一.概述\n\nJava注解（Annotation）又称Java标注。我们可以使用注解来**标注**类，构造器，方法，成员变量，参数等。\n\n**问题来了，我们标注起来有什么作用呢？**\n\n程序在**编译**或者**运行**时可以检测到这些标记，我们或者框架底层可以对有标注的类，方法等**进行一些特殊的处理**，例如：\n\n- 标记了注解`@Test`的方法就可以被当作测试方法执行，而没有标记的就不能当成测试方法执行。\n- 我们在使用框架进行开发的过程中常常会用到注解来简化开发过程，例如`@Resource`,`@Component`等。\n- 将`@Override`放在方法前，在编译时会进行格式检查，如果你这个方法并不是覆盖了超类方法则会报错。\n\n注解就如同公路边的一个个路标，在你碰到的时提醒你注意一些事或者教你该做一些事了，就好比你看到一个急转弯路标，你就知道，该减速行驶了~\n\n# 二.自定义注解\n\n除了使用Java给我们提供的那些注解，我们还可以自己定义一个注解来使用。\n\n**语法格式**：\n\n```java\npublic @interface 注解名称 {\n    public 属性类型 属性名称() default 默认值;\n}\n```\n\n注意事项：\n\n- 注解类里可以声明**零个至多个**属性\n\n- 声明与接口类`interface`有点相似，不过前面多了`@`符号！！！\n- 属性类型为`public`时，`public`可以省略不写\n- 属性名称后面必须跟上`()`\n- `default 默认值`可以不写,不写时使用注解必须提供该属性值，有默认值则可以不提供。\n- 如果注解类中**没有属性或者属性全有默认值**，在使用时可以直接写成`@注解名称`\n- 以上只是简单形式，我们下面还会使用元注解进行完善。\n\n使用示例：\n\n```java\n// 例一\npublic @interface Book {\n    \n    public String bookName() default \"\";\n    \n    double price();\n}\n\n// 例二\npublic @interface Money {\n}\n\n// 可以用在类，方法，字段等地方\n@Book(bookName = \"《活着》\", price = 29.9)\npublic class MyClient {\n\n    // 可以都写上属性值\n    @Book(bookName = \"《活着》\", price = 29.9)\n    private String name;\n\n    // bookName 有默认值也可以不写\n    // price 无默认值必须赋值\n    @Book(price = 29.9)\n    public void save() {\n        System.out.println(\"test\");\n    }\n    \n    // 可以不写()\n    @Money\n    public void save() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n**特殊属性：**\n\n- 如果注解中**只有一个**名为`value`的属性，使用注解的时候可以省略value的名称。\n- 如果**有多个属性且多个属性都有默认值**，也可以省略value的名称\n\n```java\n// 两种形式都可以省略\npublic @interface Book {\n    String value();\n}\n\npublic @interface Book {\n\tpublic String bookName() default \"\";\n    String value();\n}\n\n\npublic class MyClient {\n\n    // 使用时可以选择直接写上值\n    // @Book(value = \"test\")\n    @Book(\"test\")\n    public void save() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n# 三.元注解\n\n## (1) 介绍\n\n用来注解注解的注解。意思就是我们可以在注解类上加上一些Java给我们提供的**特定注解**，用于对其的使用与状态进一步的标注。\n\n**常见的元注解有两个**：\n\n- `@Target`:**用于约束自定义注解只能在哪些地方使用**。例如我们上述自定义注解便没有进行约束以至于可在任意允许的地方使用。\n- `@Retention`:**申明注解的声明周期**，例如标注它只存在于编译阶段或者运行阶段或者一直存在。\n\n**常用值**：\n\n- `@Target`中可使用的值定义在ElementType枚举类中，常用值如下\n  - `TYPE`：类，接口\n  - `FIELD`：成员变量\n  - `METHOD`：成员方法PARAMETER,方法参数CONSTRUCTOR,构造器\n  - `LOCAL_VARIABLE`：局部变量\n\n- `@Retention`中可使用的值定义在RetentionPolicy枚举类中，常用值如下\n  - `SOURCE`:注解只作用在源码阶段，生成的字节码文件中不存在\n  - `CLASS`:注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.\n  - `RUNTIME`:注解作用在源码阶段，字节码文件阶段，**运行阶段（开发常用)**\n\n## (2) 使用\n\n我们再使用元注解对上述自定义注解进行完善：\n\n```java\n// 标注该自定义注解存活于运行阶段\n@Retention(RetentionPolicy.RUNTIME)\n// 标注该自定义注解只能使用在方法上\n@Target(ElementType.METHOD)\npublic @interface Book {\n    \n    public String bookName() default \"\";\n    \n    double price();\n}\n\n// 测试类\n// @Book(bookName = \"666\",price = 666) 报错\npublic class MyClient {\n    \n\t// @Book(bookName = \"666\",price = 666) 报错\n    private String name;\n\n    @Book(bookName = \"666\",price = 666)\n    public void save() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n再次进行测试我们发现该注解只能在方法上使用，在其他地方使用便会产生错误。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/pL64qmnP-image.png)\n\n当然我们也可以给注解声明多个作用范围：\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD,ElementType.FIELD}) // 如此便可同时用于字段和方法上\npublic @interface Book {\n    \n    public String bookName() default \"\";\n    \n    double price();\n}\n\n// 测试类\n// @Book(bookName = \"666\",price = 666) 报错\npublic class MyClient {\n    \n\t@Book(bookName = \"666\",price = 666) \n    private String name;\n\n    @Book(bookName = \"666\",price = 666)\n    public void save() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n# 四.注解的解析\n\n## (1) 介绍\n\n我们可以通过反射判断方法或者类等是否存在注解，存在注解我们可以解析出内容。\n\n**解析常用方法**：\n\n| 方法                                                         | 说明                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| Annotation[]  getDeclaredAnnotations()                       | 获得当前对象上使用的所有注解，返回注解数组。                 |\n| T getDeclaredAnnotation(Class<T>  annotationClass)           | 根据注解类型获得对应注解对象                                 |\n| boolean isAnnotationPresent(Class<Annotation>  annotationClass) | 判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false |\n\n**解析注解的技巧**：\n\n- 注解在哪个成分上，我们就先拿哪个成分对象。\n\n-  比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解\n\n- 比如注解作用在类上，则要该类的Class对象，再来拿上面的注解\n\n- 比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解\n\n## (2) 使用\n\n同样是上述案例，我们来尝试解析获取一些注解内的内容。\n\n```java\n// 自定义注解\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD,ElementType.TYPE})\npublic @interface Book {\n    \n    public String bookName() default \"\";\n    \n    double price();\n}\n\n// 测试方法\n@Book(bookName = \"类注解\",price = 999)\npublic class MyClient {\n\n    @Book(bookName = \"方法注解\",price = 666)\n    public void save() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n我们尝试利用**反射**来解析一下\n\n```java\npublic class Test{\n    public static void main(String[] args) throws NoSuchMethodException {\n\n        // 1. 先得到类对象\n        Class<MyClient> c = MyClient.class;\n        // 2. 判断这个类上是否存在这个注解\n        if (c.isAnnotationPresent(Book.class)){\n            // 3. 直接获取该注解对象\n            Book book = c.getDeclaredAnnotation(Book.class);\n            // 4. 获取属性值\n            System.out.println(\"=====类注解======\");\n            System.out.println(book.bookName());\n            System.out.println(book.price());\n        }\n\n        // 1. 先得到方法对象\n        Method method = c.getDeclaredMethod(\"save\");\n        // 2. 判断这个方法上是否存在这个注解\n        if (method.isAnnotationPresent(Book.class)){\n            // 3. 直接获取该注解对象\n            Book book = method.getDeclaredAnnotation(Book.class);\n            // 4. 获取属性值\n            System.out.println(\"=====方法注解======\");\n            System.out.println(book.bookName());\n            System.out.println(book.price());\n        }\n    }\n}\n```\n\n运行可以看到我们成功获取到了属性值\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/q9fb9QUh-image.png)\n\n# 五.模拟Junit框架\n\n注解与反射在我们的框架的底层实现中有着广泛的应用。接下来我们便来模拟一下Junit框架。\n\n- 我们的目的是：只要是加了自定义注解MyTest的方法，就可以在启动时被触发执行\n\n1. 定义一个自定义注解MyTest，要求只能注解方法并且一直都存在\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\npublic @interface MyTest {\n}\n```\n\n2. 定义若干个方法，只要有@MyTest注解的方法就能在启动时被触发执行，没有这个注解的方法不能执行\n\n```java\npublic class MyClient {\n\n    @MyTest\n    public void test1() {\n        System.out.println(\"test1......\");\n    }\n\n    @MyTest\n    public void test2() {\n        System.out.println(\"test2......\");\n    }\n\n    public void test3() {\n        System.out.println(\"test3......\");\n    }\n\n    @MyTest\n    public void test4() {\n        System.out.println(\"test4......\");\n    }\n}\n```\n\n3. 由于Junit框架是与IDEA进行了整合所有左边才有可直接run的绿三角，我们需要自己通过反射触发。\n\n```java\n// 在MyClient里添加一个main方法,通过反射模拟启动菜单\n public static void main(String[] args) throws InvocationTargetException, IllegalAccessException {\n        // 用于触发方法\n        MyClient myClient = new MyClient();\n\n        // 1. 先得到类对象和得到方法对象\n        Class<MyClient> c = MyClient.class;\n        Method[] methods = c.getDeclaredMethods();\n\n        // 2. 遍历判断方法上是否存在这个注解\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(MyTest.class)){\n                // 3. 触发方法\n                method.invoke(myClient);\n            }\n        }\n    }\n```\n\n4. 启动可以看到只有我们添加了注解的1，2，4执行了，而没添加的则未执行\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/Np4a9zQW-image.png)\n如此我们便简单实现了Junit框架\n\n\n\n\n\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619305100524748802/SQr6zIPi-R-C.png",
        "language": null,
        "viewNum": 1,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619305100524748802",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T00:57:43.000+00:00",
        "updateTime": "2023-12-19T00:57:50.000+00:00",
        "user": {
          "id": "1619305100524748802",
          "planetCode": "6872",
          "userName": "观止.",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/OYu6LaaicHd8CDShMPqharTUTck82BzOggVOzdsF3AqPyVMRjAjEicQpvpQTQAeUFOvnsPuHLBTYNDWMgsg0r5LQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": -4,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 9,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-01-28T13:18:24.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-28T12:03:15.000+00:00",
          "updateTime": "2023-12-20T09:18:47.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1736912760828092417",
        "title": "【Java基础】消灭魔法值-常量&枚举详述",
        "description": "【Java基础】消灭魔法值-常量&枚举详述",
        "content": "\n# 一.引入\n\n在开发中我们经常会遇到用一个值（诸如数字或字符串）表示一种状态的情况，例如：\n\n- 用 1 表示男，用 0 表示女\n- 用 0 表示状态正常，用 1 表示异常，用 2 表示封禁\n- 用 admin 表示管理员，用 common 表示普通用户\n- .....\n\n如果直接在代码中书写这些数值将大大破坏代码的可维护性，即使本人亲自编写的代码，在一段时间没接触之后，需要重新上手都得重新翻阅以前写的批注，如果没有写又不记得.....更何况有些时候代码都不是自己所编写的.... \n\n\n\n阿里巴巴Java开发规范手册中有提到：**不允许任何魔法值（即未经定义的常量）直接出现在代码中**。为了提高我们代码的可维护性，这也是许多人都遵从的一点。\n\n**什么是魔法值呢？**\n\n它通常是指在代码编写时**莫名出现的数字或字符串，我们无法直接判断数值代表的含义**，必须通过联系代码上下文分析才可以明白，严重降低了代码的可读性。结合我们上述所举的例子：\n\n```java\n// 不推荐\ngender.setGender(1); // 设置性别为男\n// 这里所使用的 1 就是一个魔法值\n```\n\n除此之外，如果在代码中使用了大量的魔法值，假设我们需要对其值进行修改那么工作量也是极其巨大的而且极易遗漏。\n\n为了解决这个问题，我们可以采用如下两种方式来做信息标志和分类：\n\n- 常量\n- 枚举\n\n# 二.常量\n\n我们可以先声明一个变量并且赋值，然后再使用，但是这样做用户可以随意的修改变量值，导致安全性大大降低。由此我们可以选择使用常量。\n\n## (1) 语法\n\n- **定义**：使用了`public static final`**修饰的成员变量**，**必须有初始化值**，一旦初始化后，在执行的过程中**其值不能再被改变**。\n\n- **命名规范**：通常使用英文单词**全部大写**，**多个单词下划线连接**起来。\n\n```java\n// 使用示例，也可以写成接口形式\n// 标识用户状态常量\npublic class UserStatus {\n    // 0 -》 正常 \n    public static final Integer USER_NORMAL  = 0;\n    // 1 -》 异常\n    public static final Integer USER_ABNORMAL  = 1;\n    // 2 -》 禁止\n    public static final Integer USER_PROHIBIT  = 2;\n}\n```\n\n类似于我们正常声明成员变量，只不过为了**保证其不可修改**的特性，加上了`public static final`修饰。\n\n**补充说明**：\n\n在我们使用常量的时候，Java会在编译阶段**自动**进行“宏替换”，也就是把使用常量的地方全部替换成真实的字面量，提高一点系统的性能。\n\n```java\n// 比如我们使用常量 UserStatus.USER_NORMAL\nSystem.out.println(UserStatus.USER_NORMAL);\n// java会在编译阶段替换为字面量 0\nSystem.out.println(0);\n```\n\n## (2) 去魔法化\n\n假设我们需要将用户的状态设置为异常状态，\n\n以前我们直接使用数字，并加上注释（可能有些人注释都懒得加）：\n\n```java\n// 设置用户状态为异常\nuser.setStatus(1); // 不推荐\n```\n\n在一个规模比较小或者使用处极少的项目中可能问题不大，但如果项目规模比较庞大，开发时间跨度大，使用处比较多，那么上述写法便非常的不友好，由此我们可以使用上述所学的常量。\n\n**常量代替：**\n\n```java\n// 还是使用我们语法介绍部分声明的常量\n// 使用变量代替魔法值，设置用户状态为异常\nuser.setStatus(UserStatus.USER_ABNORMAL); // 推荐√\n```\n\n可能会有人觉得这样写也太长了，但是对于一个有代码提示的IDE来说其实并不算什么问题，更何况它的可读性明显提高了。当我们需要修改指代状态数字时，仅仅需要在`UserStatus`类中修改一次即可处处生效。\n\n# 三.枚举\n\n虽然常量也可以达成目的，但**在一些约束性比较强的情况下，枚举类更加的适合**。例如，你期待接收已定义的常量数值，事实上程序可以接受任意符合参数类型的数值。\n\n## (1) 语法\n\n枚举是Java中的一种特殊类型，需要先创建一个枚举类再进行使用。\n\n**语法格式**：\n\n```java\n修饰符 enum 枚举名称{\n     // 罗列枚举类实例的名称，以逗号（,）分隔实例,以分号（;）标识结尾\n}\n```\n\n- 示例一：\n\n  - 对于一些简单的场景，我们可以直接使用枚举示例：\n\n  ```java\n  // ,分割实例 ;标识结尾\n  public enum SeasonEnum {\n      // 上下左右\n      UP, \n      DOWN, \n      LEFT, \n      RIGHT;\n  }\n  ```\n\n  - 调用与使用抽离到单独类中的常量类似\n\n  ```java\n  public class App {\n      public static void main(String[] args) {\n          System.out.println(SeasonEnum.UP);\n          System.out.println(SeasonEnum.DOWN);\n          System.out.println(SeasonEnum.LEFT);\n          System.out.println(SeasonEnum.RIGHT);\n      }\n  }\n  ```\n\n  - 可以看到除了枚举类内置的方法以外，我们只能使用事先罗列的枚举类实例。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/cxqKuGE8-image.png)\n\n- 示例二：\n\n  - 对于一些稍复杂的情况，我们只使用实例仅仅能完成标识，无法完成存储等用途。由此我们还可以为每个实例**增加一个至多个值**。\n\n    ```java\n    public enum UserStatusEnum {\n        // 根据构造器枚举实例，此时不含无参构造器，必须要赋值枚举\n        NORMAL(0),\n        ABNORMAL(1),\n        PROHIBIT(2);\n    \n        // 必须提供对应参数构造器\n        UserStatusEnum(Integer value) {\n            this.value = value;\n        }\n        \n    \t// 不建议给用户提供二次修改枚举值的权限\n        // 可以有多个字段\n        private final Integer value;\n    \n        // 仅开放获取实例值权限\n        public Integer getValue() {\n            return value;\n        }\n    }\n    ```\n\n  - 使用上与上述类似，不过多了些许自定义方法,例如：getValue\n\n  ```java\n  public class App {\n      public static void main(String[] args) {\n          // 可以仅获取枚举值\n          System.out.println(UserStatusEnum.NORMAL); // NORMAL\n          // 还可以获取枚举值所指代的数值\n          System.out.println(UserStatusEnum.NORMAL.getValue()); // 0\n      }\n  }\n  ```\n\n  - 可以看到与上述类似，不过多了我们提供的获取值方法\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/raOTOXzn-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/gFWFEGnR-image.png)\n\n## (2) 特点\n\n- 枚举类都是继承了枚举类型：java.lang.Enum\n- 枚举**都是最终类，不可以被继承**。\n- 构造器都是私有的，枚举对外**不能通过**`new`**创建对象**。\n- 枚举类的**第一行默认都是罗列枚举对象的名称**的。\n- 枚举类相当于是**多例模式**。\n\n我们可以**反编译后**结合上述观察枚举的特征：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/0NBxj8Ol-image.png)\n\n## (3) 去魔法化\n\n假设我们同样需要将用户的状态设置为异常状态：\n\n```java\n// 设置用户状态为异常\nuser.setStatus(1); // 不推荐\n// 使用常量\nuser.setStatus(UserStatus.USER_ABNORMAL); // 推荐一√\n```\n\n我们也可以使用上述所学的枚举值进行代替\n\n```java\n// 还是使用我们语法介绍部分声明的枚举值\n// 使用枚举值代替魔法值，设置用户状态为异常\nuser.setStatus(UserStatusEnum.ABNORMAL.getValue()); // 推荐二√\n```\n\n可能有人会发现这样写其实和使用没啥区别，如果仅仅是这样用确实没什么区别。但是在方法参数列表中，让枚举类当作参数那便有很强的约束性。\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        setStatus(UserStatusEnum.NORMAL);\n    }\n\n    public static void setStatus(UserStatusEnum userStatus){\n        User user = new User();\n        user.setStatus(userStatus.getValue());\n    }\n}\n```\n\n这样一来我们要想设置用户状态便只能传递枚举类中已经存在的几个枚举实例。\n\n此外对于一些方法只能接受数值的情况，我们还先通过values获取所有值进行判断数值正确性,再进行处理。\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        setStatus(1);\n\n    }\n\n    // 假设只能接收非枚举实例类型\n    public static void setStatus(Integer status) {\n        // 判断参数是否为对于枚举实例\n        if (isTrueValue(status)) {\n            User user = new User();\n            user.setStatus(status);\n        } else {1\n            System.out.println(\"非法参数\");\n        }\n\n    }\n\n    // 判断参数是否为对于枚举实例\n    public static boolean isTrueValue(Integer num) {\n        UserStatusEnum[] values = UserStatusEnum.values();\n        for (UserStatusEnum statusEnum : values) {\n            Integer value = statusEnum.getValue();\n            if (value.equals(num)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n虽说使用常量结合哈希也能解决上述问题，但这终究需要因情况决定用法。\n\n\n\n\n\n\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619305100524748802/SjTu2JVH-R-C.png",
        "language": null,
        "viewNum": 5,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619305100524748802",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T00:54:07.000+00:00",
        "updateTime": "2023-12-19T13:03:57.000+00:00",
        "user": {
          "id": "1619305100524748802",
          "planetCode": "6872",
          "userName": "观止.",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/OYu6LaaicHd8CDShMPqharTUTck82BzOggVOzdsF3AqPyVMRjAjEicQpvpQTQAeUFOvnsPuHLBTYNDWMgsg0r5LQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": -4,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 9,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-01-28T13:18:24.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-28T12:03:15.000+00:00",
          "updateTime": "2023-12-20T09:18:47.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1736911826819506178",
        "title": "【版本控制】Git快速上手",
        "description": "【版本控制】Git快速上手",
        "content": "\n\n# 一.引入\n\n## (1) 作用  \n\n&emsp;&emsp;Git 是一个分布式版本控制系统，主要是用于管理开发过程中的源代码文件（Java类，xml文件，html页面等）。可用于**代码回溯，版本切换，多人协作开发，远程备份**等场景。\n\n## (2) 整体工作流程\n&emsp;&emsp;文件通过Git仓库来储存和管理，Git仓库分为两种：\n\n- 本地仓库：开发人员自己电脑上的Git仓库\n- 远程仓库：远程服务器上的Git仓库\n\n整体工作流程如下：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/Bd1n12LC-image.png)\n各个命令作用如下：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/4fqzrIoL-image.png)\n\n## (3) 代码托管服务 \n\n&emsp;&emsp;我们可以直接借助互联网上的一些代码托管服务来搭建远程仓库，例如gitee，github等，由于gitee服务器在国内，访问速度较快，此处建议使用gitee作为远程仓库。\n\n# 二.初始化\n\n## (1) 全局设置\n&emsp;&emsp;当安装Git后首先要做的事情是设置用户名称和email地址，因为每次Git提交都会使用该用户的信息。  \n在Git命令行中执行下面命令：\n\n- 设置用户信息\n```GIt\n git config --global user.name \"guanzhi\"\n git config --global user.email \"guanzhi\"\n```\n- 查看配置信息\n```\ngit config --list\n```\n## (2) 获取Git仓库\n&emsp;&emsp;要使用Git对我们的代码进行版本控制，首先需要获得Git仓库。获取Git仓库通常有两种方式:\n\n1. 在本地初始化一个Git仓库（\n2. 从远程仓库克隆\n\n### (2.1) 本地创建\n\n要使用Git对我们的代码进行版本控制，首先需要获得本地仓库\n\n1. 在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库\n2. 进入这个目录中，点击右键打开Git bash窗口\n3. 在窗口执行命令git init\n4. 如果创建成功后可在文件夹下看到隐藏的.git目录。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/3j2p8Fpk-image.png)\n\n### (2.2) 远程克隆\n\n```sh\ngit clone 远程仓库url\n```\n\n## (3) 相关概念\n\n- 版本库：.git隐藏文件夹就是版本库，版本库中存储了很多配置信息，日志信息和文件版本信息等\n- 工作区： 包含.git文件夹的目录就是工作区，也称为工作目录，主要用于存放开发的代码\n- 暂存区： .git文件夹中有很多文件，其中一个index文件就是缓存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方。\n  \n\nGit工作区中的文件存在两种状态\n\n1. untracked 未跟踪 （未被纳入版本控制）\n2. trackend 已跟踪（被纳入版本控制）\n    - Unmodified 未修改状态\n    - Modified 已修改状态\n    - Staged 已暂存状态  \n    \n\n注意：这些文件的状态会随着我们执行Git的命令发生变化。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/9bsId05A-image.png)\n\n# 三.常用命令\n\n## (1) 本地仓库操作\n\n### (1.1) 查看修改的状态\n作用：查看的修改的状态（暂存区、工作区）  \n命令形式：\n\n```git\ngit status\n```\n### (1.2) 添加工作区到暂存区\n作用：添加工作区一个或多个文件的修改到暂存区  \n命令形式：\n\n```\ngit add 单个文件名\n```\n- 将所有修改加入暂存区： \n```\ngit add .\n或\ngit add *\n```\n### (1.3) 提交暂存区到本地仓库\n作用：提交暂存区内容到本地仓库的当前分支  \n命令形式：\n\n```\ngit commit -m '注释内容'\n```\n### (1.4) 查看提交日志\n作用:查看提交记录\n命令形式：\n\n```\ngit log\n```\n### (1.5) 版本回退\n作用：版本切换，当前所有的代码都会回滚到切换到的版本所处状态\n命令形式：\n\n```\ngit reset --hard commitID\n```\ncommitID可以使用git log指令查看\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/2viI6ieR-image.png)\ngit reflog 这个指令可以看到已经删除的提交记录  \n\n## (2) 远程仓库操作\n\n### (2.1) 添加远程仓库\n&emsp;&emsp;此操作需先初始化本地库，然后与已创建的远程库进行对接。  \n命令：\n\n```\ngit remote add 远端名称 仓库路径  \n```\n远端名称:默认是origin，取决于远端服务器设置  \n仓库路径:从远端服务器获取此URL\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/skkJpBDI-image.png)\n\n### (2.2) 查看远程仓库\n命令：\n\n```sh\ngit remote \n或\ngit remote -v\n```\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/QKwKzz7V-image.png)\n\n### (1.3) 克隆远程仓库到本地\n&emsp;&emsp;如果你想获得一份已经存在了的Git远程仓库的拷贝，git可以克隆该Git仓库服务器上的几乎所有数据（包括日志信息，历史记录等）。  \n克隆仓库的命令格式是：\n\n```\ngit clone 仓库路径\n```\n\n### (1.4) 推送至远程仓库\n需要先将文件commit给本地仓库管理，然后推送远程\n命令：\n\n```\ngit push 远端名称 远端分支名称\n```\n&emsp;&emsp;首次push到远程仓库可能需要进行身份验证，这是只需要输入注册托管平台的账号密码即可。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/xypqt0Dd-image.png)\n\n### (1.5) 从远程仓库拉去\n&emsp;&emsp;git pull命令的作用是从远程仓库获取最新版本并合并到本地仓库。  \n命令格式:  \n\n```\ngit pull 远端名称 远端分支名称\n```\n注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存有文件，此时再从远程仓库拉去文件的时候会报错。（fatal:refusing to merge unrelated histories）  \n解决只需在命令后加入参数即可：\n\n```\ngit pull 远端名称 远端分支名称 --allow-unrelate-histories \n```\n\n## (3) 分支操作\n### (3.1) 作用 \n&emsp;&emsp;使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。同一个仓库可以有多个分支，各个分支相互独立，互不干扰。  \n&emsp;&emsp;我对此的理解是：主号开了个分身去练级，如果提高了可以融合回本体，如果bug了可以舍弃，完全不影响本体。  \n&emsp;&emsp;通过git init命令创建本地仓库时默认会创建一个master分支。\n\n### (3.2) 查看分支  \n\n- 列出所有本地分支\n```\ngit branch\n```\n- 列出所有远程分支\n```\ngit branch -r\n```\n注：如果本地仓库是通过git init获得而不是克隆则无法查看到远程分支名称。输入如下指令后再查看即可：\n```\ngit remote update origin --prune   \n# 更新远程主机origin 整理分支\n```\n- 列出所有本地分支和远程分支\n```\ngit branch -a\n```\n\n### (3.3) 创建分支\n命令：\n\n```\ngit branch 分支名称\n```\n\n### (3.4) 切换分支\n命令：\n\n```\ngit checkout 分支名称\n```\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/ArM8zyAv-image.png)\n### (3.5) 推送至远程仓库分支\n命令：\n\n```\ngit push 远端名称 分支名称\n```\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/fe237O26-image.png)\n### (3.6) 分支合并\n命令：\n\n```\ngit merge 被融合分支名称\n# 首先checkout到一个分支。\n# 然后选择将哪个分支融合于此。\n```\n- 解决冲突：\n当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：  \n1.手动处理文件中冲突的地方，改成我们想要的样子  \n2.将解决完冲突的文件加入暂存区(add)  \n3.提交到仓库(commit)  \n冲突部分的内容处理如下所示：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/LsRmSAjl-image.png)\n\n### (3.7) 删除分支\n\n- 删除分支时，可能需要做各种检查\n```\ngit branch -d 分支名称\n```\n- 不做任何检查，强制删除\n```\ngit branch -D 分支名称\n```\n\n## (4) 标签操作\n### (4.1) 作用\n&emsp;&emsp;Git中的标签，指的是某个分支某个特定时间点的状态。通过标签很方便的切换到标记时的状态（类似拍的一张照片，已经定格）。比较有代表的是人们会使用这个功能来标记发布结点（v1.0,v1.2等）。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/AhiiW8DK-image.png)\n\n### (4.2) 查看已有标签\n命令：\n\n```\ngit tag\n```\n### (4.3) 创建标签 \n\n命令：\n\n```\ngit tag 标签名称\n```\n### (4.4) 将标签推送至远程仓库\n\n命令：\n\n```\ngit push 远端名称 标签名称\n```\n### (4.5) 检出标签\n\n作用：将标签当时状态下载下来，获取当时状态下的代码。  \n命令：\n\n```\ngit checkout -b 创建新分支名称 当时状态标签名称\n```\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/4XQQXveA-image.png)\n# 四.在IDEA中操作Git\n## (1) 在IDEA中配置Git\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/En2BzYL8-image.png)\n## (2) 获取Git仓库 \n在IDEA中使用Git获取仓库有两种方式：\n\n1. 本地初始化仓库\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/r4FfBbjs-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/KUtmLN61-image.png)\n\n2. 从远程仓库克隆\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/uqiTXo73-image.png)\n   或者在初始界面：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/JbGzwzub-image.png)\n\n## (3) gitignore文件的作用\n&emsp;&emsp;告诉git项目中的哪些文件不需要git管理，例如.idea  .iml target等等。  \n\n## (4) 本地仓库操作\n\n### (4.1) 将文件加入暂存区\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/PF9S19S1-image.png)\n\n### (4.2) 将暂存区的文件提交到到版本库\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/LIv1fSdt-image.png)\n常用：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/5qsZo4yH-image.png)\n\n### (4.3) 查看日志\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/HPEHzwWh-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/1SFHREYR-image.png)\n## (5) 远程仓库操作\n\n### (5.1) 查看远程仓库&添加远程仓库\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/0sG5d1Fc-image.png)\n\n### (5.2) 推送至远程仓库\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/hazhrVLw-image.png)\n常用：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/b11JDUlf-image.png)\n\n### (5.3) 从远程仓库拉取\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/Ocr76lF2-image.png)\n常用：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/0VGItX1b-image.png)\n## (6) 分支操作\n\n### (6.1) 查看分支\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/5pMQrYUy-image.png)\n常用：（在屏幕右下角）\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/y4koL6pZ-image.png)\n\n### (6.2) 创建分支\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/bZ3RSSox-image.png)\n\n### (6.3) 切换分支\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/klBxmd8H-image.png)\n\n### (6.4) 将分支推送至远程仓库\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/dEzKbsye-image.png)\n### (6.5) 合并分支\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/LST1iPkN-image.png)",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619305100524748802/64gRV3ze-git.png",
        "language": null,
        "viewNum": 6,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619305100524748802",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T00:50:24.000+00:00",
        "updateTime": "2023-12-20T08:22:04.000+00:00",
        "user": {
          "id": "1619305100524748802",
          "planetCode": "6872",
          "userName": "观止.",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/OYu6LaaicHd8CDShMPqharTUTck82BzOggVOzdsF3AqPyVMRjAjEicQpvpQTQAeUFOvnsPuHLBTYNDWMgsg0r5LQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": -4,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 9,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-01-28T13:18:24.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-28T12:03:15.000+00:00",
          "updateTime": "2023-12-20T09:18:47.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1736568174805016577",
        "title": "【Python】学习汇总(附思维导图)",
        "description": "【Python】学习汇总(附思维导图)",
        "content": "\n>文末附带终极完整版思维导图❤️❤️❤️\n# 内容导航\n- python入门语法\n\n  - [一.基础语法](https://blog.csdn.net/m0_66570338/article/details/128360060)\n  - [二.判断语句](https://blog.csdn.net/m0_66570338/article/details/128373387)\n  - [三.循环语句](https://blog.csdn.net/m0_66570338/article/details/128423981)\n  - [四.函数使用](https://blog.csdn.net/m0_66570338/article/details/128430939)\n  - [五.数据容器](https://blog.csdn.net/m0_66570338/article/details/128471245)\n  - [六.文件基础操作](https://blog.csdn.net/m0_66570338/article/details/128496207)\n  - [七.异常处理](https://blog.csdn.net/m0_66570338/article/details/128515753)\n  - [八.模块与包](https://blog.csdn.net/m0_66570338/article/details/128537949)\n  - [九.面向对象](https://blog.csdn.net/m0_66570338/article/details/128570255)\n  - [十.类型注解](https://blog.csdn.net/m0_66570338/article/details/128577814)\n  - [十一.高阶技巧](https://blog.csdn.net/m0_66570338/article/details/128614699)\n- 操作第三方库\n  - [一.操作MySQL](https://blog.csdn.net/m0_66570338/article/details/128587909)\n# 思维导图\n> 涵盖了各篇章的大致内容，可以通过目录快速跳转查看对应章节思维导图，可针对尚不清楚的地方`点击标题跳转文章详细`复习一番~\n##  一.[基础语法](https://blog.csdn.net/m0_66570338/article/details/128360060)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/9nmQspw4-image.png)\n## 二.[判断语句](https://blog.csdn.net/m0_66570338/article/details/128373387)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/2P4TsXaf-image.png)\n## 三.[循环语句](https://blog.csdn.net/m0_66570338/article/details/128423981)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/FPGnNB3Q-image.png)\n## 四.[函数使用](https://blog.csdn.net/m0_66570338/article/details/128430939)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/68NCARYP-image.png)\n## 五.[数据容器](https://blog.csdn.net/m0_66570338/article/details/128471245)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/vN0z6PTQ-image.png)\n## 六.[文件基础操作](https://blog.csdn.net/m0_66570338/article/details/128496207)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/nELfsD5x-image.png)\n\n## 七.[异常处理](https://blog.csdn.net/m0_66570338/article/details/128515753)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/bFEaLvwh-image.png)\n## 八.[模块与包](https://blog.csdn.net/m0_66570338/article/details/128537949)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/Oyo1icav-image.png)\n\n ## 九.[面向对象](https://blog.csdn.net/m0_66570338/article/details/128570255)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/EquydI42-image.png)\n##  十.[类型注解](https://blog.csdn.net/m0_66570338/article/details/128577814)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/QKfqyXeW-image.png)\n## 十一.[高阶技巧](https://blog.csdn.net/m0_66570338/article/details/128614699)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/KyprWBmq-image.png)\n>第三方库学习与使用\n## 一. [操作MySQL](https://blog.csdn.net/m0_66570338/article/details/128587909)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/2vOaZRTm-image.png)\n\n## 系列概览（终极完整版思维导图）\n\n// todo 请求管理员上传，限制文件大小无法上传\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619305100524748802/O5BPFypJ-一.基础语法.png",
        "language": null,
        "viewNum": 13,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619305100524748802",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-18T02:04:51.000+00:00",
        "updateTime": "2023-12-19T11:11:53.000+00:00",
        "user": {
          "id": "1619305100524748802",
          "planetCode": "6872",
          "userName": "观止.",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/OYu6LaaicHd8CDShMPqharTUTck82BzOggVOzdsF3AqPyVMRjAjEicQpvpQTQAeUFOvnsPuHLBTYNDWMgsg0r5LQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": -4,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 9,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-01-28T13:18:24.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-28T12:03:15.000+00:00",
          "updateTime": "2023-12-20T09:18:47.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "273",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "35"
  },
  "message": "ok"
}